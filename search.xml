<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[语义化标签、css3新增选择器、css3新增样式]]></title>
    <url>%2F2018%2F06%2F04%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[什么是语义化很容易让编程人员、浏览器读懂代码的内容。 语义化的优点 页面结构更清晰，容易将网页分块，更便于开发维护 有利于搜索引擎的抓取能力、SEO 优化。 html5 新增常用的标签兼容性：ie9+ header : 网站头部，或者一个局域块的头部。 article : 定义一片文本区域，盛放文章等内容，常用在帖子、博客文章、评论、新闻。 nav： 盛放导航的盒子，链接排列。nav &gt; ul &gt;li &gt; a section : 局域块。article 专门盛放文本的，它可以盛放其他东西。 aside : 侧边栏，窗口左右边的能点击的锚点小块。 footer : 网站尾部，或者一个局域块的尾部。 figure : 展示图片及其描述。figcaption 定义 figure 的标题，它不能单独使用。 mark : 标记小部分内容。默认背景色是黄色，可用js改变。 canvas、svg、video、audio 等高级 h5 标签。 css3新增选择器属性选择器 E[attr] : 选择具有属性attr的E元素 E[attr = &#39;val&#39;] : 选择具有属性 attr、attr 值为 val 的E元素。 E[attr ~= &#39;val&#39;] : 选择具有属性 attr 、属性值中有一个（可能有几个属性值，它们以空格隔开）是 val 的E元素。 E[attr ^= &#39;val&#39;] : 选择具有属性attr、属性值以 val 开头的字符串的E元素，如果有多个属性值，只检测第一个值。 E[attr $= &#39;val&#39;] : 选择具有属性 attr、属性值以 val 结尾的字符串的E元素，如果有多个属性值，只检测最后一个值。 E[attr |= &#39;val&#39;] : 选择具有属性 attr、属性值是 val 或者 val 用 - 链接的的E元素。eg: div.[class |= ‘h’] E[attr *= &#39;val&#39;] : 选择具有属性 attr 、属性值包含 val 的字符串的E元素。 伪类选择器： E:first-child : 匹配父元素中第一个子元素、且元素种类为E。 E: last-child : 匹配父元素中最后一个子元素、且元素种类为E。 E:first-of-type : 匹配父元素中类型为E的第一个元素。 E:last-of-type : 匹配父元素类型中为E的最后一个元素。 E:nth-child(n) : 匹配父元素中第n个元素、元素类型为E。 E:nth-last-child(n) : 倒着数，匹配父元素中第n个、类型为E的元素。 E:nth-of-type(n) : 匹配父元素中第n个、类型为E的子元素。 E:nth-last-of-type(n): 倒着数，匹配父元素中第n个元素。 E:empty : 匹配没有内容的E元素。这里没有内容，指的是 innerHTML 为空、可以有 before、after E:target : 被锚点激活的E元素，某个元素的ID值是a链接的 href ，并且在前面加上#。例如：&lt;div id=&#39;box&#39;&gt;&lt;/div&gt; &lt;a href=&#39;#box&#39;&gt;&lt;/a&gt; 两个栓在一起。当鼠标点击a时候，div就会触发:target伪类样式。 E:checked: 已被选择的单、多选按钮。 E:enabled : 匹配可用状态的表单元素E。 E:disabled : 匹配不能使用的表单元素E。 E:not(选择器) : 匹配不包含指定选择器的元素 E:focus : 匹配获得焦点的元素E。 伪元素选择器： E::after : 选择E的伪元素 after E::before : 选择E的伪元素 before content 不能省，默认是内联元素，通常需要定位。 E::placeholder : 修饰表单元素E里面的 placeholder 属性值的样式。通常放在 input 里面，起到提示作用，当点击 input 时候，placeholder 仍然出现。通常 placeholder 是通过js模拟。 E::selection : 鼠标选择的样式（背景、color、text-shadow）。 E::first-letter : 第一个文字。 E::first-line : 第一行 伪类、伪元素注意点 对空元素添加 ::before ::after伪元素后，:empty 伪类还是有作用的。 两个伪元素::before ::after 通常和动画、转换、过度结合。实现图片层叠效果、达到节约元素的目的。 nth-child、nth-of-type 里面可以写： 数字、英文、类似 ab + b 表达式。 伪元素和伪类的区别伪类是直接给元素添加样式。伪元素是先添加元素再去定义样式。 css3 新增属性新增边框属性 border-radius : 设置边框圆角。分为水平方向和竖直方向上的圆角设置，用/隔开。 IE9+ box-shadow : 添加盒子阴影。多个阴影用 , 隔开。 IE9+ border-image : 用图片绘画边框（很少用）。 新增背景属性 background-clip 、 background-origin 、background-break。用的少。 background-size : cover | contain | auto | 具体长度、宽度。设置背景大小，通常也是考虑到背景图的大小来设置盒子大小（不是雪碧图）。 cover : 保证背景会覆盖盒子，但是可能背景不完全显示。 contain : 能等比缩放到盒子的边或者宽，但是不一定会完全覆盖盒子。 背景的复合写法：background: [其他颜色] background-image [background-repeat background-position / background-size]; 多背景用逗号隔开。 新增的文本效果 white-space : normal | nowrap | pre | pre-wrap 规定 空格、换行、缩进的处理方式。使超出文本出现省略号：white-space: nowrap; overflow: hidden; text-overflow:ellipsis; word-wrap : normal | break-word 对单词是否拆分。 text-shadow : 文本阴影。规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-full-color : 设置文字填充色。个人觉得和 color 并无区别。 text-stroke-color : 设置文本描边色。 text-stroke-width : 设置文字边界宽度。 更多的css3新增属性具体参见：css手册]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5 语义化标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 指向]]></title>
    <url>%2F2018%2F05%2F26%2Fthis-%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this 指向情形如下： 全局下的 this 指向 对象字面量内部 构造函数内部 call、apply、bind 手动改变 this 指向 es6箭头函数内部 全局下的 this 指向在浏览器中，全局下的 this 指向 window 对象；在 node 环境中，则指向 global 对象。 1234var fn = function() &#123; console.log( this ); &#125;; // windowfn(); // 等同this.fn()、window.fn()console.log( this ); //window 对象字面量内部的 this 指向很容易认为 this 就是指向该对象字面量，其实这种情况只是其中之一。正确的判断出 this 指向需要看哪个对象直接调用了函数。 12345678910111213141516var age = 0; var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;var fn = obj2.getAge = obj1.getAge;fn(); // window.fn() 0obj2.getAge(); // 2 构造函数内部的 this 指向通过 new 命令的执行机制，知道构造函数内部的 this 就是指向创建出的实例。 12345678910111213141516171819function Person(name, age, sex) &#123; var a = 0; function sss() &#123; // 闭包 a ++; console.log(a); &#125; this.say = sss; this.name = name; this.age = age; this.sex = sex;&#125;var oPersopn = new Person('Bob', 20, '男');oPersopn.say(); // 1oPersopn.say(); // 2var oPersopn1 = new Person('Alice', 18, '女');oPersopn1.say(); // 1 call、apply、bind 手动改变 this 指向函数内部 this 就是使用 call、apply 、bind 调用函数时第一个参数。以 call 为例： 123456789101112var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;obj1.getAge.call(obj2); // 2 es6箭头函数内部 this 指向记住它和父级作用域的 this 一致。 123456789101112131415161718var age = 0;var obj = &#123; age: 1, getAge1: function() &#123; setTimeout(function() &#123; console.log( this.age ); &#125;); &#125;, getAge2: function() &#123; setTimeout(() =&gt; &#123; console.log( this.age ); &#125;); &#125;&#125;obj.getAge1(); // 0obj.getAge2(); // 1 一道经典面试题1234567891011121314var a = 10;var foo = &#123; a: 20, bar: function()&#123; var a = 30; console.log( this.a ); &#125;&#125;foo.bar(); // 20 没毛病(foo.bar)(); // 20 匿名函数自执行，但该函数仅限于foo对象中的变量使用。等同于foo.bar()(foo.bar, foo.bar)(); // 10 逗号运算符，返回最右边的表达式。匿名函数自执行,this指向window(foo.bar = foo.bar)(); // 10 foo.bar被重新赋值一个函数，然后再执行这个匿名函数，但是此时的函数被赋值之后，this指向了全局变量window]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this 指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前端存储方式 cookie localStorage sessionStorage indexDB (待续) cookie cookie 运行在服务器端，存放在客户端（用户浏览器）。 cookie 是绑定在域名上的。不同域名存放的 cookie 位置和内容不同。cookie 能够在同个域名多页面使用，但正常情况下，不能跨域使用。 不同浏览器的 cookie 存储位置不同，更不能相互使用。 cookie 存放内容空间很小，不同浏览器存放大小不同，一般4KB左右，20个左右。 cookie 默认无效时间是会话结束。当用户关闭浏览器时就会失效。 cookie 安全性不高，别人能够拿到本地 cookie 然后进行 cookie 欺骗。 cookie 作用：实现身份验证、保存用户登陆信息、信息跟踪等。 cookie 的工作原理当页面每次发送 http 请求时，浏览器都会携带与目标 URL（domain+path） 相关的 cookie 信息。有则自动会添加到 request cookie 中（即使不需要某一 cookie。 所以，cookie 大小不宜太大），伴随着 http 请求发送到服务器。 cookie 的属性name value domain path expires/max-age httponly secure 等。 name value: cookie 的键值对儿。 domain: 控制 cookie 对那个域有效。默认值是创建 cookie 时所在网页的域名。即 URL 中的 host。 手动设置 cookie 的域的话，可以设置 domain 为本域、父域，不能是公共后缀。如：本域为 www.google.com.hk 。可以将 domain 设置为 www.google.com.hk、google.com.hk，但是不能设置为 .com.hk com.hk .hk 等。 path: 控制 cookie 作用目录。默认是创建 cookie 的文件目录。这样 domain+path（即URL） 就决定了cookie 能够被哪些页面共享了。 expries/max-age: 规定 cookie 的过期时间。默认 cookie 的生存期是会话结束时, cookie 失效。expires 是一个时间点,单位毫秒； max-age 是一个以秒为时间的时间段。max-age 可能的值：负数(有效期为会话结束)、0(删除cookie)、正数(有效期为创建时刻 + 最大时间)。例如，设置过期时间是两年后过期：expires = new Date(new Date().getTime() + 2 365 24 3600 1000).toGMTString() 或者 max-age = 2 365 24 * 3600; httponly: 用来指定 cookie 能否通过js访问到。默认情况下，是可以通过js获取、更改、删除 cookie 的。cookie 设置 httpOnly 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。客户端不能通过js设置 httponly 值的，必须是服务端设置。好处是将 cookie 设置为 httponly 可以减轻 xss 攻击的危害，防止 cookie 被窃取，提高 cookie 的安全性。 secure: 用来设置 cookie 在 https 等安全协议下，cookie 才会被发送到服务端。默认情况下，不管是http、https 协议的请求都会把 cookie 发送到服务端。注意：只有是在 https 安全协议下的 web 站点，才能设置 secure 的 cookie; 只保证 cookie 与服务器之间的数据传输加密，而保存在本地的 cookie 文件并不加密。唯一一个非名值对儿，只包含 secure 一个单词例如：document.cookie = ‘_name=bai; secure’; cookie 的编码防止 cookie 的 key、 value 中含有空格、分号、等号特殊符号。所以 cookie 在设置时需要编码，获取时需要解码。编码、解码：escape/unescape encodeURIComponent/decodeURIComponent encodeURI/decodeURI可参考：cookie 编码介绍 js实现对cookie的增加、删除、修改1234567891011121314151617181920212223242526272829303132333435var dealCookie = &#123; // name, value, time(以年为单位), domain, path, secure, httponly(只能在服务端设置) set : function (json)&#123; var name = json.name, value = json.value, time = json.time, domain = json.domain, path = json.path, secure = json.secure, cookieStr = encodeURIComponent(name) + '=' + encodeURIComponent(value); if(time) cookieStr += '; expires=' + new Date(new Date().getTime() + time * 365 * 24 * 3600 * 1000).toGMTString(); if(domain) cookieStr += '; domain=' + domain; if(path) cookieStr += '; path=' + path; if(secure &amp;&amp; location.protocol.slice(0, -1) === 'https') cookieStr += '; secure'; document.cookie = cookieStr; &#125;, // 找到匹配项返回 get : function (name)&#123; var regArr = document.cookie.match( new RegExp('(\\s|^)' + encodeURIComponent(name) + '=([^;]*)(;|$)') ); return regArr ? decodeURIComponent(regArr[2]) : null; &#125;, // 当cookie的name/domain/path相同时，才可删除 unset : function (name, domain, path) &#123; var obj = &#123;&#125;; obj.name = name; obj.domain = domain; obj.path = path; obj.time = -1; dealCookie.set(obj); &#125;&#125;; 其他链接: 详解cookie localStorage 本地持久化存储，存储容量可达到5M以上，除非手动删除，否则一直存在。、 localStorage 存储的信息在同域内共享。受到同源策源影响，不能跨域。 localStorage 的数据也是以键值对儿形式存储，但不像cookie一样往返于客户端和服务端之间，避免浪费带宽。 localStoarge 一些属性、方法 localStorage.length; 获取localStorage的长度 localStorage.setItem(k, v); （可以适当使用JSON.stringify/JSON.parse） localStorage.getItem(k); localStorage.removeItem(k); 局部删除 localStorage.clear(); 全部删除 localStoarge 缺点 localStorage 是对字符串操作，如果存储数据很多，会消耗内存空间，使页面变卡。 localStorage 内的数据在隐私模式下不可读取。 localStorage 不会被爬虫爬取到，不要用它完全代替URL传参。 localStorage 的storage事件1window.addEventListener('storage', function(e)&#123;...&#125;, false); 需要注意的是： 在本页进行localStorage操作（新增、修改、删除）时，本业不会触发storage事件，但是别的页面会触发。在IE里面，本页面也会触发storage事件。 storage事件对象e有很多属性，重要的有。key、newValue、oldValue、url。 sessionStoarge 受同源策源的影响，数据只能在本标签页存储，不同窗口（标签页）的 sessionStoarge 数据不可共享。 有和localStoarge 相同的API，都是Storage类的实例。 sessionStoarge和localStorage的区别：持久化存储、窗口级别的存储。 indexDB]]></content>
      <categories>
        <category>javascript</category>
        <category>h5</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象 OOP]]></title>
    <url>%2F2018%2F05%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP%2F</url>
    <content type="text"><![CDATA[对象对象是实物的抽象，也可以说它是一个容器，其中封装了属性和方法。 面向对象的特点面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。 构造函数工厂化的方式生成对象，如果实例对象属性、方法各不同，可放在构造函数内部。 如果有相同的属性、方法，那就直接把它们挂载在原型对象上。 构造函数内部机制（new 命令干了什么？） 创建了空的中间对象 将中间对象的原型 __proto__ 指向构造函数的 prototype 属性，this 指向中间对象。 执行构造函数内部代码，给中间对象挂载属性、方法。 隐式返回 this 。 构造函数返回值构造函数返回值默认是已经封装好了的 this 对象。如果返回基本类型，则返回值无效，相当于 new 命令会忽略这支语句，但是一旦返回 object 类型的数据，将会替代 this 。 12345678910111213function Demo1(name) &#123; this.name = name; return 'test'&#125;function Demo2(age) &#123; this.age = age; return [1,2,3]&#125;new Demo1('Bob') // &#123;name: Bob&#125;new Demo2(20) // [1,2,3] 原型每个函数都有 prototype 属性,该属性值是一个对象，即原型对象。原型对象出现的原因是挂载实例的公共属性和方法，减少创建每个实例的内存消耗。原型内部有一属性是指向构造函数的 constructor 。通过构造函数访问到原型对象：构造函数.prototype 实例对象访问原型对象实例对象.__proto__ 或者 Object.getPrototypeOf(实例对象)（推荐）综上,有一个恒等式; 实例对象.__proto__ === 构造函数.prototype 函数对象的原型函数不仅含有 prototype 属性，同时它也是对象，是 Function 实例化的结果。有如下结论： 123456var Test = function() &#123; alert(1); &#125;;Test.__proto__ === Function.prototype // trueTest.prototype.__proto__ === Object.prototype; // trueFunction.prototype === Fucntion.__proto__ // trueFunction.__proto__.prototype // undefinedFunction.__proto__.__proto__ // Object.prototype 原型链每个实例化对象都有原型，而原型又是对象，也能找到原型，一直寻找原型至 Object.prototype （它的原型为null）结束。 123var oTest = new Test();oTest.__proto__.__proto__ === Object.prototype // trueObject.prototype.__proto__ // null in、for-inin 判断对象是否含有某个属性，for-in 遍历属性如果在该对象并未找，它会顺着原型链查找，一直找到源头 Object.prototype 下的属性、方法，没有则返回 undefined，通常继承会利用这种特性；for-in 遍历对象及其祖先的可枚举、非 Symbol 属性时，如果只遍历自身的属性、方法，可以使用 Object.hasOwnProperty(obj) 来实现过滤。 另外，可用 isPrototypeOf 来判断该对象是否式参数的原型对象。 继承子类拥有父类的属性和方法，但是不对其进行更改，且每个子类实例互不影响。 构造函数继承构造函数继承又称类继承，意思是在子类的构造函数内部调用父类的构造函数（期间修改this指向）。 123456789101112131415function Parent(name) &#123; this.name = name;&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); // 构造方法继承的关键处 this.age = age; this.sex = sex;&#125;var child = new Child('Bob', 20, '男');child.showName(); // 报错 可以实现对父类属性、方法的继承。但是却继承不到父类原型上的属性、方法。 原型继承通过prototype实现原型继承，将子类原型对象指向父类的一个实例。 1234567891011121314151617181920function Parent(name) &#123; this.name = name; this.num = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child(20, '男');var child1 = new Child(21, '女');child.num.push(4);child1.num // [1,2,3,4]child.name // undefined 缺点：如果父类上存在引用类型的数据，一旦一个子类对其改变，其他子类的数据同样改变; 子类无法改变父类内部属性值，即使父类需要参数也不能传参，一旦传参，所有实例含有相同属性值。 组合继承继承父类、原型上的属性及其方法 123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 缺点是：调用了两次父类的构造函数。第一次为了继承父类的属性、方法。第二次是为了继承父类原型上的属性、方法，那何必不直接将子类原型指向父类的原型呢？ 在子类遍历属性时，岂不更快吗？ 不用创建父类实例，岂不更节约空间？ 组合继承的优化123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Parent.prototype; Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 似乎已经完美地继承了父类且所有子类实例可以共享父类原型的属性方法。但是，没办法知道子类的父类是谁啊？另外，子类和父类共用一个prototype，一旦子类修改了prototype，父类的prototype也会修改(比如constructor)。 最终的组合优化1234567891011121314151617181920212223242526272829function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child );/* 如果不支持Object.create(): if(!Object.create) &#123; Object.create = function(obj) &#123; function Fn() &#123;&#125;; Fn.prototype = obj; return new Fn(); &#125;; &#125;*/ Object.create(Parent.prototype)：以父类的原型为原型来创建一个空对象，子类原型指向这个空对象。这样就可以很清楚地看到子类地父类。 获取父类名：实力对象.__proto__.__proto__.constructor.name es6实现继承123456789101112131415161718192021222324class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; console.log( this.name ); &#125;&#125;class Child extends Parent &#123; constructor(name, age, sex) &#123; super(name); this.age = age; this.sex = sex; &#125; getAge() &#123; console.log( this.age ); &#125;&#125;var child = new Child('Bob', 20, '男');console.log( child );]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js 面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js获取DOM节点]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8E%9F%E7%94%9Fjs%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[获取DOM元素通过元素ID获取受到ID唯一性的限制，只能获取一个元素； 兼容所有浏览器 1document.getElementById('el-id') 通过元素的类名获取获取 obj 对象下的含有该类名的所有元素，返回一个类数组 HTMLCollection； 不兼容ie8- 1obj.getElementsByClassName('el-className') 通过标签获取obj 对象下是该标签的节点，返回一个类数组 HTMLCollection； 兼容所有浏览器。 1obj.getElementsByTagName('el-name') H5新增获取元素的Api，不兼容ie7-可获取单个节点、多个节点, 返回的是 NodeList 类数组 12obj.querySelector('选择器') obj.querySelectorAll('选择器') children 获取获取对象obj下第index（index是非负整数）个子元素 1obj.children[index] 动态获取和静态获取动态获取获取的可以是 HTMLCollection、动态节点。DOM元素进行添加、修改删除子元素，该动态列表也会相应的更新，可看做 HTMLCollector 是 DOM 节点的引用。 对应的动态方法： obj.getElementsByTagName(‘el-name’) obj.getElementsByClassName(‘el-className’) obj.children[index] 静态获取获取的可以是 NodeList、静态节点。DOM 元素进行添加、修改删除子元素，该动态列表不会更新，可看做 HTMLCollector 是 DOM 节点的复制。通常来说，静态方法会比动态方法慢。 对应的动态方法： obj.querySelector(‘选择器’) obj.querySelectorAll(‘选择器’) jq获取的节点列表、对象，jq的获取类似于querySelector 举个栗子来表明以上两种获取方式1234567891011121314151617181920212223242526272829303132&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;!function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.getElementsByTagName('li'); console.log( aLi.length ); // 6 oUl.removeChild(aLi[aLi.length - 1]); /*父元素把最后一个li对象删除，aLi发生变化*/ console.log( aLi.length ); // 5&#125;();+function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.querySelectorAll('li'); console.log( aLi.length ); // 5 var oLi = document.createElement('li'); oUl.appendChild(oLi); /*父元素在最后添加一个li对象,aLi无变化*/ console.log( aLi.length ); // 5&#125;(); &lt;/script&gt; 遍历类数组先把类数组 HTMLCollection、NodeList、arguments 转换成数组，再使用数组方法遍历： 123456789101112131415161718192021&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var aLi = document.querySelectorAll('li'); [].slice.call(aLi).forEach((oLi, index) =&gt; &#123;console.log( oLi, index );&#125;); [...aLi].forEach((oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); Array.from(aLi, (oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原生js获取DOM节点</tag>
      </tags>
  </entry>
</search>
