<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Web安全]]></title>
    <url>%2F2018%2F07%2F02%2FWeb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[xssxss：cross site scripting 跨站脚本攻击。攻击原理：攻击者向网页恶意植入 html 标签或者 js 脚本。比如：植入了表单提交 html 代码，当用户提交时，目标服务器是攻击者的服务器，而不是用户原以为的信任站点；植入的 js 脚本，js 可获得用户的 cookie 信息。 防范方法： 限制用户提交内容的长度，也可以限定特定字符； 对用户输入、提交的内容进行正则过滤、编码或者或者转码； 加密传输重要内容； 对于稍微重要的 cookie 信息给设置 httpOnly 属性，让前端 js 脚本不能获取 cookie 信息。 CSRFCSRF：Cross Site Request Forgery 跨域请求伪造攻击原理：伪装成站点用户进行攻击。攻击者通过盗用用户的身份信息，并以用户的名义发送恶意请求。 防范方法： 验证 HTTP Referer 字段。在 HTTP 头中有 Referer 字段记录该 HTTP 请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是 csrf 攻击，拒绝该请求。因为通常来说，Referer字段应和请求的地址位于同一域名下。 在 http 请求头中加入 token。 这种的话在请求的时候加一个 token，值可以是随机产生的一段数字，token 是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现 token 没有，或者通过查询数据库不正确，那么就拒绝该请求。 如果想防止一个账号避免在不同的机器上登录，那么我们就可以通过 token 来判断，如果a机器登录后，我们就将用户的 token 从数据库清除，从新生成，那么另外一台b机器在执行操作的时候，token 就失效了，只能重新登录，这样就可以防止两台机器登同一账号。 控制台注入代码黑客诱骗用户去浏览器控制台粘贴东西实现植入 js 脚本。和 xss 攻击原理差不多的。例子天猫商城： 钓鱼原理：伪装正常网站样式，让用户输入用户名、密码等个人隐私信息。或者跳转非法的雷同页面。比如：在危险网站上蹦出来一个 qq 登陆，做得和官网上一模一样，如果用户不看域名的化，直接输入信息就会导致信息丢失；在正确域名下输入信息，通过植入 js 代码，把网页链接变为非法网站，这个非法网站和合法网站及其类似（这有点像 xss）。 网页验证码验证码出现的目的：证明当前登陆站点的是个人，并不是通过暴力破解实现登陆、注册的机器。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html 面试小结]]></title>
    <url>%2F2018%2F07%2F01%2Fhtml%E9%9D%A2%E8%AF%95%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[seoseo: Search Engine Optimization 搜索引擎优化。seo 主要通过网站结构建设、内容调整、代码优化来提升网站，使网站更容易被搜索引擎抓取。 前端能做的 seo（主要是代码优化） 合理地设置网站 title、description、keywords, 因为搜索引擎对三者的权重依次减少。 不同页面不同 title； description 需要言简意赅地概括网站内容； keywords 例举网站重要关键字； html 标签语义化。类似地，搜索引擎对不同标签的搜索权重不同。 图片的 alt 属性尽量添加上。 由于搜索引擎抓取不到 iframe 的内容，因此尽量不用 iframe 标签。 代码精简。 img 标签 title、alt属性区别title 是 html 标签公共的 attribute，鼠标悬停上面会出现的文字。alt 是图片未显示的替代文本。 当图片正常显示时，title有效，alt无效； 当图片因路径问题不能正常显示时，title、alt全有效。 语义化的理解编写 html 代码结构时，尽量使用语义化标签。这样做的优点有： 代码结构清晰，便于开发和维护。 有利于搜索引擎的解析和seo的优化。 介绍一下你对浏览器内核的理解浏览器内核一开始包括渲染引擎和js引擎（解析和执行js来实现网页的动态效果），随着js引擎的独立，浏览器内核倾向于指渲染引擎。渲染引擎用来解析网页语法和渲染网页，它决定了浏览器如何显示网页内容和页面的格式信息，不同的浏览器内核对网页语法的解释不同，所以同一页面在不同内核的浏览器内渲染的结果可能不同，这也是网页hack的主要原因。常见的浏览器内核有： Trident 内核：IE、360 Webkit 内核：Chrome、Safari Presto 内核：Opero Gecko 内核：firefox EdgeHTML 内核：Microsoft Edge html5有哪些新特性、移除了那些元素？新特性： 语义化标签 新增选择器、属性 拖拽 媒体播放 video、audio 离线存储 增强的表单控件 地理位置 全双工通信协议 webscoket 跨窗口通信 postmessage 页面可见性 文件上传 formData canvas、svg 移除的元素：font、br、hr、frame、frameset等。 html5 离线存储怎么用，及其工作原理在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。原理：HTML5的离线存储是基于一个新建的 .manifest 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像 cookie 一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 请描述一下 cookies，sessionStorage 和 localStorage 的区别共同点：存储在客户端，都受到同源策略的限制。区别： cookies 伴随着 http 请求往返于浏览器和服务器之间，每次 http 请求都会自动携带相应的 cookies（即使不需要）。但 sessionStorage 和 localStoarge 则不会，它们仅是本地存储。 存储大小。cookies 存储大小为4k左右，一小段文本信息。但是 sessionStorage 和 localStorage 则大得多，至5M左右。 sessionStorage 和 localStorage 的区别是作用域不同。 localStorage 可作用域同源下所有网页，sessionStorage 只是单页面（窗口）存储，即使同一个页面也不能实现数据共享。 iframe 优缺点优点： 能够原封不动的展示页面。它是对 html 页面的封装，方便功能相同的网页代码复用。 iframe 内部代码不受外部 css、js 影响，避免 css、js代码冲突。 缺点： 搜索引擎抓取不到 iframe 内容，不利于 seo。 加载速度慢，并且会阻塞主页面的 onload 事件。 牵涉到跨域问题。 产生多页面，不易管理，且会增加 http 请求。 因此：如果需要使用 iframe，最好是通过 javascript 动态给 iframe 添加 src 属性值，可以避免1-2缺点。 WEB标准以及W3C标准是什么web 标准：指的是网站分为三个部分结构、表现和行为。 结构是指 html 标签组成的 dom 架构。 表现指使用 css 修饰网页标签元素。 行为指 js 使得用户和页面具有交互性，同时页面结构或者表现发生变化。 w3c 标准：是对 web 标准规范化的要求。也就是在编程时的代码规范，主要有一下几点： 对 html 结构 标签小写且要闭合。 标签不允许随意嵌套，标签语义化。 对 css、js 外联 css 样式表和 js 脚本。做到结构、表现、行为的模块化。 遵循 css、js 代码规范。 xhtml 和 html有什么区别?HTML：超文本标记语言。XHTML：加强版的 HTML。XHTML 比 HTML 更加严格: XHTML 文档必须有根元素； 标签必须闭合； XHTML 元素一律小写； XHTML 元素必须被正确的嵌套； HTML 和 XML 的区别？XML：可扩展标记语言。 XML 用来传输、存储数据，也可用来作配置文件； HTML 用来显示数据。 XML 使用的标签不用预先定义。且标签必须成对出现，对大小写敏感，代码中空格不会被删减。 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?Doctype: 告知浏览器用标准模式渲染页面。严格模式：浏览器按照 w3c 标准渲染页面。混杂模式：浏览器仿照老式浏览器的行为，并且在此基础上兼容新的特性标准。即宽松向后兼容。 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？HTML5不像HTML4一样基于SGML（Standard Generalized Markup Language 标准通用标记语言），也不需要引用DTD（Document Type Definition 文档类型定义）。但是用doctype来规定浏览器的行为。 HTML全局属性(global attribute)有哪些，HTML5新增的全局属性有哪些？全局属性指：可使用在任何标签元素上的 attribute。全局属性有：style、title、class、id等。h5 新增的全局属性有：draggable、contenteditable、spellcheck等等。 Canvas和SVG有什么区别？canvas 是通过 js 绘制 2d 图形。可保存为 .(png|jpg) 图片，通过内定的 canvas api 可制作不依赖 dom 的动画。svg是通过使用 xml 绘制的 2d 矢量图，图片放大缩小不会失桢。 浏览器内多个标签页之间的通信 cookies、localStorage的事件监听； querytring 地址栏传参，在URL上面拼接参数，在目标页面用正则获取location.href内部的queryString b与strong的区别、i与em的区别？strong 是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong会重读，而 b 是展示强调内容。i 内容展示为斜体，em 表示强调的文本； HTML5的form如何关闭自动完成功能？给 form 或者 input 属性 autocomplete = &quot;off&quot; href和url的区别href: 指向网络资源所在位置，建立和当前元素（锚点）和当前文档（链接）的关系。并行下载资源并不会停止对当前文档的处理（link引入css时）url: 请求src资源时，会下载资源应用到文档中，比如js脚本、img图片。暂停其他资源的下载处理，直到该资源下载、执行完毕。通常把js放到尾部原因。 css 和 js 文件位置css 应该放在 &lt;/head&gt; 之前，因为由 css 解析过来的规则树和由 html 解析而来的 dom 数需要合并成渲染树，这样更快显示页面；如果放在 &lt;/body&gt; 之前，就是先解析出的 dom 树，这样导致初始页面无样式、排版混乱，当后来解析的 css 规则树和 dom 树再合并时，才会正确的排版，重新渲染页面，浪费资源、性能不高。js 应该放在 &lt;/body&gt; 之前，因为只有页面渲染完成后，通过 js 才能操作 dom 节点。当 js 放到 &lt;/head&gt; 之前时，一则获取不到 dom 节点，无法进行 dom 操作；二则 js 代码需要下载、解析、执行，这需要时间啊，并且 js 解析、执行和页面渲染是互斥的，只有当js 代码完成解析、执行后才能进行页面渲染，会影响页面的加载速度，用户体验贼差。 渐进式渲染渐进式渲染是指浏览器不用等待页面所有资源渲染完成后才显示给用户看，而是边下载边渲染，或者说通过监听用户事件逐步渲染网页。举例：图片懒加载、瀑布流、分页等 ####]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>html 面试小结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript声明变量及解构]]></title>
    <url>%2F2018%2F06%2F30%2Ftypescript%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%8F%8A%E8%A7%A3%E6%9E%84%2F</url>
    <content type="text"><![CDATA[typescript 变量声明typescript 也可用 var、let、const 声明变量，但是更推荐 es6 所提倡 let、const 声明变量。const 声明是对 let 进一步的约束，变量值不能更改。 同 es6 类似地：使用 let、const 声明的变量有一下便利： 让变量使用更加规范 变量不能重复定义； 变量不能生命前使用，会造成短暂性死区； 变量所处的 {} 内存在块级作用域，不需要再像 es5 一样使用闭包来保存变量； 变量只在自己块作用下有效； const 与 let 声明的变量唯一不同是：使用 const 声明的变量不能更改变量值，其他语法一样； 变量不声明不允许使用这种机制可解决使用 var 带来变量提升的弊端； 12345678910111213141516171819202122232425262728293031323334// 变量不能重复定义let str = '123';let str = '456'; // Errorlet str1 = '123';var str1 = '456'; // Errorvar str2 = '123';var str2 = '456'; // 没什么卵用，覆盖// 变量不能生命前使用，会造成短暂性死区n++; // Errorlet n = 0;// 块级作用域for(let i = 0; i &lt; 10; ++i) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 100 * i);&#125;// 变量只在自己块作用下有效&#123; let n = 0;&#125;n ++; // Error// const 声明的变量不能更改变量值const LEN = 20;LEN = 1; // Error 不能改变常量值（只读属性也是类似） 解构数组解构、对象解构 对数组解构，需要索引相同； 对对象解构，需要 property 相同； 1234567891011121314151617181920212223242526272829303132333435363738394041// 交换变量值let a: number = 1, b: number = 2;[b, a] = [a, b];let [a, ...b] = [1,2,3,4]; // 使用 ...展开数组let [,a,,b] = [1,2,3,4]; // 选择性取数组数据let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a, b &#125; = o; // 这里不需要clet &#123;c, ...d&#125; = o; // 使用 ...展开对象 d是个对象// 当对象解构时，重命名属性名let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a: c, b: d &#125; = o; // 注意：此时a,b不能被访问到；冒号不再标注变量的类型// 解构时，使用默认值function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject;&#125;// 在声明时使用解构，并提供默认值function f(&#123; a, b = 0 &#125; = &#123; a: "haha" &#125;): void &#123; console.log(a, b);&#125;f(&#123; a: "yes" &#125;); f(); f(&#123;&#125;); // Error 既然选择传参，定要传递属性a]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript声明变量及解构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript基础数据类型]]></title>
    <url>%2F2018%2F06%2F30%2Ftypescript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[typescript 类型注解在 typescript 使用 : 类型 来标注变量具体的数据类型，对 javascript 变量随意性有了具体类型约束。 布尔值 boolean1let bool: boolean = true; 数字 numbertypescript 和 javascript 一样，所有数字都是以浮点数形式存储的，支持二、八、十、十六进制数字的变量。1234let number1: number = 0b1010, number2: number = 100, number3: number = 0o172, number4: number = 0x17fb; 字符串 string12345let str1: string = 'hello', str2: String = 'hello', str3: string = "hello", str4: string = `hello`, str5: string = `$&#123;str4&#125;` 任意值 any使用 any 类型的变量目的：躲避掉编译时类型检查 1234// 当你只知道一部分数据类型时，可以使用 any 声明数组let arr: any[] = [1, true, 'hello', function() &#123; alert(1); &#125;];arr[100] = true; 数组 Arraytypescript 使用两种方法定义数组。 在元素类型后面紧跟着 [] 使用数组泛型 Array&lt;元素类型&gt; 123let numArr: number[] = [1,2,3,4,5,6], strArr: Array&lt;string&gt; = ['hello', 'world'], arr: any[] = [1, true, 'hello', function() &#123; alert(1); &#125;]; 元组 Tuple如果一个数组的项的类型和个数都确定的话，可以使用元组来声明变量。 12let myTuple1: [string, number] = ['hello', 123];let myTuple2: [string, number] = [ 123', hello']; // Error 数据类型和数据要匹配 当访问已知索引的数据时，可使用其 api 来操作数据；访问一个越界的元素的，此时会使用联合类型 (string | number):123456let tuple: [string, number] = ['hello', 123];let ch = tuple[0].slice(-1);let ch1 = tuple[1].slice(-1); // Error 数组没有该方法tuple[3] = 'world'; // 'world' 的数据类型为string，在联合类型(string|number)中tuple[4] = true; // Error boolean不在联合类型中 枚举 enum枚举是对 javascript 数据类型的补充。意义为：物以类聚。为一组数据赋予一好听的名字。枚举成员不能有数值 1234567891011// 普通枚举使用enum Color &#123;Green, Red, Pink&#125;let myColor: Color = Color.Green; // 0 已知项=&gt;索引let myColor1: string = Color[2]; // 'Pink' 已知索引=&gt;具体项// 手动改变枚举项的索引, 后面项索引一次叠加enum Color1 &#123;Green, Red = 3, Pink, Orange = 10&#125;let myColor: Color1 = Color1.Pink; // 4 空值 void 只能给数据类型为 void 的变量赋值为 undefined | null； 函数返回值类型为 void，实际返回值和 javascript 一样为 undefined； 1234function fn(msg: string): void&#123; console.log(msg); // 'void 测试！'&#125;console.log( fn('void 测试！') ); // undefined undefined 和 null默认情况下，这两种类型是其他类型的子类型。比如：可以使用 undefined|null 赋值给类型为 number 的变量。 NeverNever 表示永不存在值的类型。never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。(个人认为这个类型很鸡肋) 类型断言可认为类型转换, 不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。类型断言两种方式： &lt;数据类型&gt; as 推荐使用，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 123let str: any = 'hello world!';console.log( (&lt;string&gt;str).length, (str as string).length ); // 12 12 注意这种类型转换是能是大范围转换为小范围，例如：any =&gt; 其他类型，不能 number =&gt; string123let strNum: string = '156';console.log( (strNum as number).toFixed(2) ); // Error 不能转换！]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript基础数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typescript 简介]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%88%9D%E5%A7%8Btypescript%2F</url>
    <content type="text"><![CDATA[typescript 的概念typescript 是 javascript 的扩展，是 javascript 的超集，并且是一门由微软开发的跨平台、跨浏览器的开源语言，主要用于开发大型应用级软件。 typescript 和 javascript正如上述，typescript 是 javascript 的超级，是 javascript 的扩展，typescript 具有 es5-7 全部语法规范。 typescript 和 javascript有一下联系： 引入类、接口、模块的概念，虽然 javascript 之前也有，不过 typescript 中更加规范。 将 .ts 文件编译成 .js文件时，存在类型检查，不再像 js 一样拥有变量类型及个数的随意性。 始终于 javascript。在 .ts 文件中可直接写 js 代码，最后编译成也是 js 代码（毕竟浏览器的脚本语言默认就是 javascript）。 安装 typescriptnpm 安装 npm i -g typescript npm update -g typescript 更新 typescript 到最新版 tsc -v 查看 typescript 版本（更过 tsc 命令, tsc --help）。 demo: 使用 typescript 编写 helloworld12345function printHelloWorld(msg) &#123; return `$&#123;msg&#125; write hello world!`;&#125;console.log( printHelloWorld('typescript') ); 源文件： 使用 tsc + 文件路径 -w(--watch) 自动编译 .ts 文件，默认是编译成与 .ts 文件同目录的 .js 文件。由此可见，.ts 文件可自动被编译成 ECMAscript5 语法规则的 .js文件。 结果： 更多 typescript学习链接： typescript 中文文档 typescript 具体语法详解 typescript 源码 网友博客]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript 简介</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F06%2F29%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的概念函数之间存在嵌套关系，并且内部函数可随时访问外部函数的局部变量（或者形参）。它是依托函数来创建的，因为只有函数有自己的作用域结构。 作用能避免污染全局环境下保存函数内部的局部变量。仅允许外界通过特定的函数接口来访问（或设置）局部变量。利用这一特性，可发现不少前端库为了实现模块化、不污染全局均使用了闭包，比如比较熟悉的 jquery。 危害由于闭包暴露出的外部接口可被随时调用，因此该函数常驻内存中，该函数接口又会依赖外部函数，因此整个外部函数及其内部私有数据常驻内存中，这样的话内存开销就比较大了，会导致网页性能的问题。在 ie 中可能会造成内存泄漏。 解决方式是：在函数退出之前全部删除变量或者给其赋值为 null，便于垃圾回收。 使用闭包 demo123456789// 闭包保存变量值for(var i = 0; i &lt; 10; ++i) &#123; ((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 10 * i); &#125;)(i);&#125; 12345678910111213141516171819202122232425262728// 闭包模拟数据库let dataOperation = (() =&gt; &#123; var jsonArr = [&#123; id: 1, username: 'Bob', pwd: '123456' &#125;, &#123; id: 2, username: 'Alice', pwd: '654321' &#125;, &#123; id: 3, username: 'Jack', pwd: '666666' &#125;]; return &#123; getData(id) &#123; return jsonArr.filter(json =&gt; json.id === id); &#125;, setData(myJson) &#123; let index = jsonArr.findIndex(json =&gt; json.username === myJson.username); jsonArr.splice(index, 1, myJson); console.log(jsonArr); &#125; &#125;&#125;)();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 特殊特性]]></title>
    <url>%2F2018%2F06%2F09%2FVue-%E7%89%B9%E6%AE%8A%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[keyvue 给相同父元素的子元素绑定 key 值的目的：唯一标识元素。当不同元素有相同的标识时，会发生渲染错误。常用之处： 和 v-for 一起使用进行列表渲染 在 transition-group 组件中标识不同子元素。 1234567891011121314151617181920212223242526272829303132333435/*CSS.fade-enter-active, .fade-leave-active &#123; opacity: 1; transition: opacity 2s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125;HTML&lt;div id="wrap"&gt; &lt;button @click="flag = !flag"&gt;点击&lt;/button&gt; &lt;transition-group name="fade" tag="div"&gt; &lt;p v-show="flag" :key="p1"&gt;这是p1元素&lt;/p&gt; &lt;p v-show="flag" :key="p2"&gt;这是p2元素&lt;/p&gt; &lt;a v-show="flag" :key="a"&gt;这是a元素&lt;/a&gt; &lt;/transition-group&gt; &lt;div v-for="item in arr" :key="item.id"&gt;&#123;&#123;item.id&#125;&#125; -- &#123;&#123;item.name&#125;&#125;&lt;/div&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true, arr: [ &#123;id: 1, name: 'Bob'&#125;, &#123;id: 2, name: 'Hello'&#125; ] &#125;&#125;); ref用来给元素/组件添加引用信息。所有信息会记录在父组件 $refs 对象上。通过这个信息可以获取到对应的 DOM 元素或者子组件实例，从而可对DOM` 元素或者子组件实例进行更多的操作!1234567891011121314151617181920212223242526272829303132/*HTML&lt;div id="wrap"&gt; &lt;div ref="box"&gt;这是普通DOM元素!&lt;/div&gt; &lt;my-component ref="mycomponent"&gt;&lt;/my-component&gt; &lt;button @click="Click"&gt;点击&lt;/button&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true, arr: [ &#123;id: 1, name: 'Bob'&#125;, &#123;id: 2, name: 'Hello'&#125; ] &#125;, methods: &#123; Click() &#123; console.log( this.$refs ); // &#123;box: div, mycomponent: VueComponent&#125; &#125; &#125;, components: &#123; 'my-component': &#123; template: `&lt;p&gt;这是子组件!&lt;/p&gt;` &#125; &#125;&#125;); 重要的：基于 ref 特性，我们可以实现复杂的 DOM 操作。通过 $refs、$parent 更容易获取子组件、父组件的信息。12345678910111213141516171819202122232425262728293031323334353637383940414243/*HTML&lt;div id="wrap"&gt; &lt;div ref="box"&gt;这是普通DOM元素!&lt;/div&gt; &lt;my-component ref="mycomponent"&gt;&lt;/my-component&gt; &lt;button @click="Click"&gt;点击&lt;/button&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true, arr: [ &#123;id: 1, name: 'Bob'&#125;, &#123;id: 2, name: 'Hello'&#125; ] &#125;, methods: &#123; Click() &#123; this.$refs.box.innerHTML = '修改div内容'; // 普通 DOM 操作 console.log(this.$refs.mycomponent.msg); // '这是子组件!' &#125; &#125;, components: &#123; 'my-component': &#123; template: `&lt;p @click="getMsgParent"&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125;, methods: &#123; getMsgParent() &#123; console.log(this.$parent.msg); // 'hello world' &#125; &#125; &#125; &#125;&#125;); 注意: $refs 是根实例被挂载之后（mounted）才有的，并且它不是响应式的，不能在模板中做数据绑定。1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;div ref="box"&gt;这是普通DOM元素!&lt;/div&gt; &lt;button @click="$refs.box.innerText += 'lalala'"&gt;点击&lt;/button&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, beforeCreate() &#123; console.log('box' in this.$refs); // false &#125;, created() &#123; console.log('box' in this.$refs); // false &#125;, beforeMount() &#123; console.log('box' in this.$refs); // false &#125;, mounted() &#123; console.log('box' in this.$refs); // true &#125;&#125;); slot插槽。实现自定义元素组件的内容分发，同时可实现父组件向子组件的模板传递信息。 不使用 slot 弊端 值得注意的是：如果不使用 slot 进行内容分发且组件元素有内容的话，则自定义组件元素内容将会丢失，因为整个组件会被其 template 替换 1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt;啊啊啊！我显示不出来啊&lt;/my-component&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125; &#125; &#125;&#125;); 匿名插槽/默认插槽匿名插槽没有 name 属性，在模板中在需要的位置直接使用 slot ，会把整个自定义组件元素的全部内容放在此位置。 1234567891011121314151617181920212223242526272829303132/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;div&gt; hhh, 我会在模板中显示的！ --- 并且能够传值&#123;&#123;parentMsg&#125;&#125;&lt;/div&gt; &lt;/my-component&gt;&lt;/div&gt;*/var myComponent = &#123; template: `&lt;div&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;!-- 将显示在这 --&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125;&#125;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', parentMsg: 'a msg from parent!' &#125;, components: &#123; 'my-component': myComponent &#125;&#125;); 具名插槽使用 name 给多个插槽起名，使组件元素内容分开至 template 不同位置，并且具名插槽可以在模板中复用。 12345678910111213141516171819202122232425262728293031323334353637/*&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;header slot="head"&gt; &lt;span&gt;这是根元素头部信息---&#123;&#123;headMsg&#125;&#125;&lt;/span&gt; &lt;/header&gt; &lt;footer slot="foot"&gt; &lt;div&gt;这是根元素尾部信息---&#123;&#123;footMsg&#125;&#125;&lt;/div&gt; &lt;/footer&gt; &lt;/my-component&gt;&lt;/div&gt;*/var myComponent = &#123; template: `&lt;div&gt; &lt;slot name="head"&gt;&lt;/slot&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;slot name="foot"&gt;&lt;/slot&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125;&#125;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', headMsg: '我通过slot传给子组件的头部信息!', footMsg: '我通过slot传给子组件的尾部信息!', &#125;, components: &#123; 'my-component': myComponent &#125;&#125;); 作用域的插槽/带数据的插槽在组件元素内部 template 元素下为插槽内容，在子组件内 slot 中绑定数据，在父作用域下的子组件元素内容中通过 slot-scope 接收并渲染出数据。1234567891011121314151617181920212223242526272829303132333435363738394041/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;template slot-scope="numArr"&gt; &lt;li v-for="(item, index) in numArr.data" // data就是子组件绑定的prop :key="index" &gt; &#123;&#123;item&#125;&#125; &lt;/li&gt; &lt;/template&gt; &lt;/my-component&gt;&lt;/div&gt;*/var myComponent = &#123; template: `&lt;div&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;slot :data="parentData"&gt;&lt;/slot&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!', parentData: [1,2,3,4] &#125; &#125;&#125;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', headMsg: '我通过slot传给子组件的头部信息!', footMsg: '我通过slot传给子组件的尾部信息!', &#125;, components: &#123; 'my-component': myComponent &#125;&#125;); isis 和 component 搭配使用实现组态组件的来回切换。并且还可能在组件外部嵌套缓存 keep-alive 或者 动画 transition。 123456789101112131415161718192021222324252627282930313233343536373839/*HTML&lt;div id="wrap"&gt; &lt;transition name="fade" mode="out-in"&gt; &lt;keep-alive&gt; &lt;component :is="currentComponent"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;button @click="change"&gt;组件切换&lt;/button&gt;&lt;/div&gt;*/var component1 = &#123; template: '&lt;div&gt;组件1&lt;/div&gt;'&#125;;var component2 = &#123; template: '&lt;div&gt;组件2&lt;/div&gt;'&#125;;var component3 = &#123; template: '&lt;div&gt;组件3&lt;/div&gt;'&#125;;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', currentComponent: 'component1' &#125;, methods: &#123; change() &#123; this.currentComponent = 'component' + (this.currentComponent.slice(-1) % 3 + 1); &#125; &#125;, components: &#123;component1, component2, component3&#125;&#125;);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 特殊特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 全局API]]></title>
    <url>%2F2018%2F06%2F07%2FVue-%E5%85%A8%E5%B1%80API%2F</url>
    <content type="text"><![CDATA[全局 API不在构造器内部、挂载在构造函数 Vue 下的 API，也就是 Vue 的静态方法。 Vue.directive自定义指令。实现对普通 DOM 元素底层操作。语法：Vue.directive({String}id, {funciton|object}defination)、`directives分类： 全局自定义指令 可用于所有 Vue 实例 局部自定义指令 仅仅作用于当前组件 自定义指令的钩子函数: bind 只调用一次，指令第一次绑定到元素上调用。用来初始化设置。 inserted 被绑定的元素插入到父节点时调用（要保证父节点存在）。 update 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind 只调用一次，指令与元素解绑时调用。 每个自定义指令钩子函数的内部参数（直接拷贝官网上的）: el 绑定的 DOM 元素，可读。 binding 包含众多属性的对象: name 指令名，不包含 v- 前缀。 value 指令绑定值，通常是 string、json格式。 oldValue 指令绑定的前一个值，仅在 update、componentUpdated钩子中使用。无论值是否改变都可用。 expression 字符串形式的指令表达式。例如：v-mydirective=&quot;1 + 1&quot;, expression 就是 1 + 1。 arg 传给指令的参数，可选。例如：v-mydirective:foo, arg就是foo。 modifiers 一个包含修饰符的对象。例如：v-my-directive.foo.bar，修饰符对象是：{foo: true, bar: true} VNode Vue编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldNode 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中使用。 1234567891011121314151617181920212223242526272829303132/*HTML &lt;div id="wrap"&gt; &lt;input type="text" v-demo:foo.bar.lala="1 + 1" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;textarea v-focus&gt;&lt;/textarea&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;, directives: &#123; demo: &#123; inserted(el, binding, VNode) &#123; console.log(el); // &lt;input type="text"&gt; console.log(binding.name); // focus console.log(binding.value); // 2 console.log(binding.expression); // 1 + 1 console.log(binding.arg); // foo console.log(binding.modifiers); // &#123;bar: true, lala: true&#125; &#125; &#125;, focus: &#123; inserted(el) &#123; el.focus(); &#125; &#125; &#125;&#125;); Vue.extendvue 扩展构造器。主要来服务 Vue.component 来创建全局组件。语法：Vue.extend({object}options)需要注意的是： 组件和主组件有一点很大不同：data 选项必须是函数类型，且要返回 json 类型。（防止因为组件复用时，一数据变化其他也会变化）。 该全局 API 的模板选项会覆盖挂载点。 123456789101112131415/*HTML &lt;div id="wrap"&gt;&lt;/div&gt;*/var myExtend = Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; msg: 'Vue.extend demo!' &#125; &#125;&#125;);new myExtend().$mount('div'); Vue.filter过滤器。用来简单过滤后台请求的数据。语法：Vue.filter({string}id, {function}defination)、filters注意： 过滤器的 function 选项第一个参数是被过滤的数据。 多过虑器（前一个过滤器返回值作为后一个过滤器的第一个参数），用 | 隔开。 12345678910111213141516171819202122/*HTML &lt;div id="wrap"&gt;&#123;&#123;msg | msgReverse(flag)&#125;&#125;&lt;/div&gt; 全局过滤器 Vue.filter('msgReverse', function(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125;);*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;, filters: &#123; // 局部过滤器 msgReverse(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125; &#125;&#125;); Vue.component全局注册组件，相对于局部组件不需要引入。语法： Vue.component({string}id, {object|function}defination)。 12345678910111213141516171819202122232425262728293031323334/* HTML&lt;div id="wrap"&gt; &lt;my-component1&gt;&lt;/my-component1&gt; &lt;my-component2&gt;&lt;/my-component2&gt;&lt;/div&gt;*/Vue.component('my-component1', Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;));// 实现同样的功能，第二个参数直接使用 &#123;&#125; 形式，比 Vue.extend 更高效、简洁!Vue.component('my-component2', &#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;&#125;); Vue.use引入组件（插件）。语法：Vue.use({object|function}plugin) 123456// 先使用require引入通过npm安装的包，在Vue对象上引入插件。 var VueRouter = require('vue-router'), Vue = require('vue'), VueAwesomeSwiper = require('vue-awesome-swiper');Vue.use(VueRouter).use(VueAwesomeSwiper)....]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 全局API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 内部指令]]></title>
    <url>%2F2018%2F06%2F06%2FVue-%E5%86%85%E9%83%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-text更新元素的 innerText，但不会渲染带有标签的字符串。 1234567891011/*HTML &lt;div v-text="msg"&gt;&lt;/div&gt; // 如同模板字符串 &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; */var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;&#125;); 使用 v-text 内部指令和使用模板字符串看似效果一样，但是当网速慢导致 data 未编译成功时，v-text 就不会将 msg 渲染出；但是模板字符串却很尴尬的暴露出来了，这时需要使用 v-cloak 了。 v-html更新元素的 innerHTML ，如果在前端操作该 innerHTML（复杂 HTML），通常把它作为组件剥离出去。当然也可以直接动态渲染可信的 HTML 。渲染未知来源（用户提供的内容）的 HTML 这是非常危险的，因为容易受到 xss 攻击。 1234567891011/*HTML &lt;div v-html="msg"&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: '&lt;p&gt;hello world!&lt;/p&gt;' &#125;&#125;); v-show条件渲染。根据表达式来改变data 内部数据值的真假，从而来改变元素 css 中 display属性。 12345678910111213141516/*HTML&lt;div id="wrap"&gt; &lt;div v-show="flag"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click="flag = !flag"&gt;toggle show&lt;/button&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;&#125;); v-if v-else v-else-if条件渲染。根据表达式来改变data 内部数据值的真假，从文档中清除/显示指定元素，和 v-show 不同的是，它并不通过改变元素 css 中 display属性来控制元素的显示隐藏，而是直接动态添加/删除元素。v-else 必须在 v-if/v-else-if 后面; v-else-if 前面必须有 v-if/v-else 1234567891011121314151617/*HTML&lt;div id="wrap"&gt; &lt;div v-if="isMan"&gt;I am a man!&lt;/div&gt; &lt;div v-else-if="isAlice"&gt;I am Alice!&lt;/div&gt; &lt;div v-else&gt;I am a woman!&lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; isMan: false, isAlice: false &#125;&#125;); v-for列表渲染。遍历并渲染 array、object、number、string。更多的是遍历 json 数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*HTML&lt;div id="wrap"&gt; &lt;div class="demo-string"&gt; &lt;ul&gt; &lt;li v-for="(ch, index) in str" :key="index"&gt;&#123;&#123;ch&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-number"&gt; &lt;ul&gt; &lt;li v-for="(n, index) in arr" :key="index"&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json-arr"&gt; // important! &lt;ul&gt; &lt;li v-for="item in jsonArr" :key="item.id"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json"&gt; &lt;p v-for="item in myJson"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; str: 'abcdefg', arr: [1,2,3,4,5], jsonArr: [&#123; id: 1, name: 'Bob' &#125;, &#123; id: 2, name: 'Alice' &#125;, &#123; id: 3, name: 'Jack' &#125;], myJson: &#123; name: 'Facker', age: 20, sex: '男' &#125; &#125;&#125;); 可注意到：使用 v-for 渲染列表时，Vue 建议给每一项绑定一个唯一 key 属性，它用来保证数据的唯一性，如果有相同的 key 值，将会导致渲染错误。 v-on事件监听。简写成 @, 分为两类： 用在普通 HTML 元素上来监听 DOM 事件。实现相关的逻辑处理功能。 用在自定义元素组件上来监听子组件触发的自定义事件，从而实现子组件通过事件流的方式向父组件传递消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*HTML&lt;div&gt; &lt;button @click="fn1"&gt;按钮1&lt;/button&gt; &lt;button @click="fn2('haha', $event)"&gt;按钮2&lt;/button&gt; &lt;my-component @my-event='fn3'&gt;&lt;/my-component&gt; &lt;!-- 子组件触发my-event自定义事件时，父组件执行fn3函数。注意此时形参中的$event不再是事件对象event，而是子组件向父组件传递的信息。 但是在实参处写$event也没意义，因为可以在形参接受到全部消息 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button @click="toParentMsg"&gt;子组件按钮!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; toParentMsg() &#123; this.$emit('my-event', this.msg, 'gogo'); // 按钮点击时，触发自定义事件my-event &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn1(event) &#123; // 监听DOM事件，如果无实参则methods中对应函数的第一个形参是事件对象event console.log(event); &#125;, fn2(str, event) &#123; // 监听DOM事件，如果有实参则使用$event向形参传递事件对象event console.log( str, event ); &#125;, fn3(str1, str2) &#123; // 监听子组件my-event事件 console.log( str1, str2 ); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); 事件修饰符: 对事件的附加修饰。 .prevent 阻止默认事件 .stop 阻止事件冒泡 .native 监听根组件的原生事件。用来自定义元素组件触发原生事件时，调用根组件内部函数。 还有其他事件修饰符… Vue 官网 123456789101112131415161718192021222324252627282930313233343536373839// .native demo/*HTML&lt;div&gt; &lt;my-component @click.native="fn"&gt;&lt;/my-component&gt; &lt;!-- 注意：事件是绑定在自定义元素组件上的，而不是子组件模板中的普通元素上，否则会调用子组件内部的fn方法 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button&gt;点击试试!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; fn() &#123; console.log('hahaha'); &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn() &#123; console.log('lalala'); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); v-bind绑定 DOM 属性，分为： 绑定合法属性，属性值是 data 内部的值。 绑定自定义属性，通过 props 实现父组件向子组件传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 以绑定 class、style 两个合法属性为例/*css.classA &#123; width: 100px; height: 100px; &#125;.classB &#123; background: skyblue; border-radius: 2px;&#125;*//*HTML&lt;div id="wrap"&gt; &lt;!-- 绑定 style --&gt; &lt;div :style="&#123; width: width + 'px', height: height + 'px', borderRadius: borderRadius + 'px', background: bgColor &#125;"&gt; &lt;/div&gt; &lt;div :style="styleObj"&gt;&lt;/div&gt; &lt;div :style="[styleObj1, styleObj2]"&gt;&lt;/div&gt; &lt;!-- 绑定 class --&gt; &lt;div :class="&#123; classA: 'classA', classB: 'classB' &#125;"&gt; &lt;/div&gt; &lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!', width: 100, height: 100, borderRadius: 2, bgColor: 'pink', styleObj: &#123; width: '100px', height: '100px', background: 'pink' &#125;, styleObj1:&#123; width: '100px', height: '100px' &#125;, styleObj2:&#123; background: 'skyblue', borderRadius: '2px' &#125;, classA: 'classA', classB: 'classB' &#125;&#125;);// 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。/*HTML&lt;div id="wrap"&gt; &lt;my-component :to-child="msg"&gt;&lt;/my-component&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt; &lt;h4&gt;这是子组件!&lt;/h4&gt; &lt;p&gt;父组件向子组件传递的消息是--&#123;&#123;toChild&#125;&#125;&lt;/p&gt; // 传递过来的消息在子组件模板中得到应用 &lt;/div&gt;`, props: ['toChild'] &#125; &#125;&#125;); 总结： 绑定多个内敛样式不如动态添加 class更方便。 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。极其重要！ v-model双向绑定。在表单控件 input、textarea、select或组件 components 上创建双向绑定。v-model 修饰符： .lazy 用表单的 change 事件代替 input 事件。 .trim 过滤掉首位空格。 .number 将字符串格式的 value 转换成数字。 v-model 仅是语法糖，负责监听用户的输入事件 input 来更新数据。底层一点: v-model 是靠 v-bind 对 value 值的绑定和监听表单 input 事件。 123456789101112131415161718192021222324/*HTML&lt;div id="wrap"&gt; &lt;!-- &lt;input type="text" v-model="msgInput"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; 等同下面--&gt; &lt;input type="text" :value="msgInput" @input="msgInput = $event.target.value"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; &lt;!-- 组件上的双向绑定就是父子组件的通信过程 props、$emit --&gt; &lt;my-component v-model="msgComponent"&gt;&lt;/my-component&gt;&lt;p&gt;&#123;&#123;msgComponent&#125;&#125;&lt;/p&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msgInput: 'hello world!', msgComponent: 'my msg from component!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;input type="text" :value="value" @input="$emit('input', $event.target.value)"/&gt;`, props: ['value'] &#125; &#125;&#125;); v-pre跳过编译，显示原来的插值样式。123456789101112/*HTML&lt;div id="wrap" v-pre&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; // 不显示 hello 而是 &#123;&#123;msg&#125;&#125;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-cloak避免实例未准备好而出现插值样式的尴尬页面。需要和 css 样式一同使用。1234567891011121314151617181920/*css[v-cloak] &#123; display: none;&#125;*//*HTML&lt;div id="wrap" v-cloak&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-once单次渲染元素/组件后，元素/组件及其子节点全部作为静态内容不会被刷新渲染。对低开销的静态组件使用 v-once 指令可以优化性能。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 内部指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签、css3新增选择器、css3新增样式]]></title>
    <url>%2F2018%2F06%2F04%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[什么是语义化很容易让编程人员、浏览器读懂代码的内容。 语义化的优点 页面结构更清晰，容易将网页分块，更便于开发维护 有利于搜索引擎的抓取能力、SEO 优化。 html5 新增常用的标签兼容性：ie9+ header : 网站头部，或者一个局域块的头部。 article : 定义一片文本区域，盛放文章等内容，常用在帖子、博客文章、评论、新闻。 nav： 盛放导航的盒子，链接排列。nav &gt; ul &gt;li &gt; a section : 局域块。article 专门盛放文本的，它可以盛放其他东西。 aside : 侧边栏，窗口左右边的能点击的锚点小块。 footer : 网站尾部，或者一个局域块的尾部。 figure : 展示图片及其描述。figcaption 定义 figure 的标题，它不能单独使用。 mark : 标记小部分内容。默认背景色是黄色，可用js改变。 canvas、svg、video、audio 等高级 h5 标签。 css3新增选择器属性选择器 E[attr] : 选择具有属性attr的E元素 E[attr = &#39;val&#39;] : 选择具有属性 attr、attr 值为 val 的E元素。 E[attr ~= &#39;val&#39;] : 选择具有属性 attr 、属性值中有一个（可能有几个属性值，它们以空格隔开）是 val 的E元素。 E[attr ^= &#39;val&#39;] : 选择具有属性attr、属性值以 val 开头的字符串的E元素，如果有多个属性值，只检测第一个值。 E[attr $= &#39;val&#39;] : 选择具有属性 attr、属性值以 val 结尾的字符串的E元素，如果有多个属性值，只检测最后一个值。 E[attr |= &#39;val&#39;] : 选择具有属性 attr、属性值是 val 或者 val 用 - 链接的的E元素。eg: div.[class |= ‘h’] E[attr *= &#39;val&#39;] : 选择具有属性 attr 、属性值包含 val 的字符串的E元素。 伪类选择器： E:first-child : 匹配父元素中第一个子元素、且元素种类为E。 E: last-child : 匹配父元素中最后一个子元素、且元素种类为E。 E:first-of-type : 匹配父元素中类型为E的第一个元素。 E:last-of-type : 匹配父元素类型中为E的最后一个元素。 E:nth-child(n) : 匹配父元素中第n个元素、元素类型为E。 E:nth-last-child(n) : 倒着数，匹配父元素中第n个、类型为E的元素。 E:nth-of-type(n) : 匹配父元素中第n个、类型为E的子元素。 E:nth-last-of-type(n): 倒着数，匹配父元素中第n个元素。 E:empty : 匹配没有内容的E元素。这里没有内容，指的是 innerHTML 为空、可以有 before、after E:target : 被锚点激活的E元素，某个元素的ID值是a链接的 href ，并且在前面加上#。例如：&lt;div id=&#39;box&#39;&gt;&lt;/div&gt; &lt;a href=&#39;#box&#39;&gt;&lt;/a&gt; 两个栓在一起。当鼠标点击a时候，div就会触发:target伪类样式。 E:checked: 已被选择的单、多选按钮。 E:enabled : 匹配可用状态的表单元素E。 E:disabled : 匹配不能使用的表单元素E。 E:not(选择器) : 匹配不包含指定选择器的元素 E:focus : 匹配获得焦点的元素E。 伪元素选择器： E::after : 选择E的伪元素 after E::before : 选择E的伪元素 before content 不能省，默认是内联元素，通常需要定位。 E::placeholder : 修饰表单元素E里面的 placeholder 属性值的样式。通常放在 input 里面，起到提示作用，当点击 input 时候，placeholder 仍然出现。通常 placeholder 是通过js模拟。 E::selection : 鼠标选择的样式（背景、color、text-shadow）。 E::first-letter : 第一个文字。 E::first-line : 第一行 伪类、伪元素注意点 对空元素添加 ::before ::after伪元素后，:empty 伪类还是有作用的。 两个伪元素::before ::after 通常和动画、转换、过度结合。实现图片层叠效果、达到节约元素的目的。 nth-child、nth-of-type 里面可以写： 数字、英文、类似 ab + b 表达式。 伪元素和伪类的区别伪类是直接给元素添加样式。伪元素是先添加元素再去定义样式。 css3 新增属性新增边框属性 border-radius : 设置边框圆角。分为水平方向和竖直方向上的圆角设置，用/隔开。 IE9+ box-shadow : 添加盒子阴影。多个阴影用 , 隔开。 IE9+ border-image : 用图片绘画边框（很少用）。 新增背景属性 background-clip 、 background-origin 、background-break。用的少。 background-size : cover | contain | auto | 具体长度、宽度。设置背景大小，通常也是考虑到背景图的大小来设置盒子大小（不是雪碧图）。 cover : 保证背景会覆盖盒子，但是可能背景不完全显示。 contain : 能等比缩放到盒子的边或者宽，但是不一定会完全覆盖盒子。 背景的复合写法：background: [其他颜色] background-image [background-repeat background-position / background-size]; 多背景用逗号隔开。 新增的文本效果 white-space : normal | nowrap | pre | pre-wrap 规定 空格、换行、缩进的处理方式。使超出文本出现省略号：white-space: nowrap; overflow: hidden; text-overflow:ellipsis; word-wrap : normal | break-word 对单词是否拆分。 text-shadow : 文本阴影。规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-full-color : 设置文字填充色。个人觉得和 color 并无区别。 text-stroke-color : 设置文本描边色。 text-stroke-width : 设置文字边界宽度。 更多的css3新增属性具体参见：css手册]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5 语义化标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 指向]]></title>
    <url>%2F2018%2F05%2F26%2Fthis-%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this 的出现javascript 函数可在不同环境下执行，因此需要使用 this 来标识函数所在的执行环境。也就是说，设计 this 的目的就是在函数内部指代函数当前的运行环境的。 this 指向情形如下： 全局下的 this 指向 对象字面量内部 构造函数内部 call、apply、bind 手动改变 this 指向 es6箭头函数内部 全局下的 this 指向在浏览器中，全局下的 this 指向 window 对象；在 node 环境中，则指向 global 对象。 1234var fn = function() &#123; console.log( this ); &#125;; // windowfn(); // 等同this.fn()、window.fn()console.log( this ); //window 对象字面量内部的 this 指向很容易认为 this 就是指向该对象字面量，其实这种情况只是其中之一。正确的判断出 this 指向需要看哪个对象直接调用了函数。 12345678910111213141516var age = 0; var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;var fn = obj2.getAge = obj1.getAge;fn(); // window.fn() 0obj2.getAge(); // 2 构造函数内部的 this 指向通过 new 命令的执行机制，知道构造函数内部的 this 就是指向创建出的实例。 12345678910111213141516171819function Person(name, age, sex) &#123; var a = 0; function sss() &#123; // 闭包 a ++; console.log(a); &#125; this.say = sss; this.name = name; this.age = age; this.sex = sex;&#125;var oPersopn = new Person('Bob', 20, '男');oPersopn.say(); // 1oPersopn.say(); // 2var oPersopn1 = new Person('Alice', 18, '女');oPersopn1.say(); // 1 call、apply、bind 手动改变 this 指向函数内部 this 就是使用 call、apply 、bind 调用函数时第一个参数。以 call 为例： 123456789101112var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;obj1.getAge.call(obj2); // 2 es6箭头函数内部 this 指向记住它和父级作用域的 this 一致。 123456789101112131415161718var age = 0;var obj = &#123; age: 1, getAge1: function() &#123; setTimeout(function() &#123; console.log( this.age ); &#125;); &#125;, getAge2: function() &#123; setTimeout(() =&gt; &#123; console.log( this.age ); &#125;); &#125;&#125;obj.getAge1(); // 0obj.getAge2(); // 1 一道经典面试题1234567891011121314var a = 10;var foo = &#123; a: 20, bar: function()&#123; var a = 30; console.log( this.a ); &#125;&#125;foo.bar(); // 20 没毛病(foo.bar)(); // 20 匿名函数自执行，但该函数仅限于foo对象中的变量使用。等同于foo.bar()(foo.bar, foo.bar)(); // 10 逗号运算符，返回最右边的表达式。匿名函数自执行,this指向window(foo.bar = foo.bar)(); // 10 foo.bar被重新赋值一个函数，然后再执行这个匿名函数，但是此时的函数被赋值之后，this指向了全局变量window]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this 指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前端存储方式 cookie localStorage sessionStorage indexDB (待续) cookie cookie 运行在服务器端，存放在客户端（用户浏览器）。 cookie 是绑定在域名上的。不同域名存放的 cookie 位置和内容不同。cookie 能够在同个域名多页面使用，但正常情况下，不能跨域使用。 不同浏览器的 cookie 存储位置不同，更不能相互使用。 cookie 存放内容空间很小，不同浏览器存放大小不同，一般4KB左右，20个左右。 cookie 默认无效时间是会话结束。当用户关闭浏览器时就会失效。 cookie 安全性不高，别人能够拿到本地 cookie 然后进行 cookie 欺骗。 cookie 作用：实现身份验证、保存用户登陆信息、信息跟踪等。 cookie 的工作原理当页面每次发送 http 请求时，浏览器都会携带与目标 URL（domain+path） 相关的 cookie 信息。有则自动会添加到 request cookie 中（即使不需要某一 cookie。 所以，cookie 大小不宜太大），伴随着 http 请求发送到服务器。 cookie 的属性name value domain path expires/max-age httponly secure 等。 name value: cookie 的键值对儿。 domain: 控制 cookie 对那个域有效。默认值是创建 cookie 时所在网页的域名。即 URL 中的 host。 手动设置 cookie 的域的话，可以设置 domain 为本域、父域，不能是公共后缀。如：本域为 www.google.com.hk 。可以将 domain 设置为 www.google.com.hk、google.com.hk，但是不能设置为 .com.hk com.hk .hk 等。 path: 控制 cookie 作用目录。默认是创建 cookie 的文件目录。这样 domain+path（即URL） 就决定了cookie 能够被哪些页面共享了。 expries/max-age: 规定 cookie 的过期时间。默认 cookie 的生存期是会话结束时, cookie 失效。expires 是一个时间点,单位毫秒； max-age 是一个以秒为时间的时间段。max-age 可能的值：负数(有效期为会话结束)、0(删除cookie)、正数(有效期为创建时刻 + 最大时间)。例如，设置过期时间是两年后过期：expires = new Date(new Date().getTime() + 2 365 24 3600 1000).toGMTString() 或者 max-age = 2 365 24 * 3600; httponly: 用来指定 cookie 能否通过js访问到。默认情况下，是可以通过js获取、更改、删除 cookie 的。cookie 设置 httpOnly 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。客户端不能通过js设置 httponly 值的，必须是服务端设置。好处是将 cookie 设置为 httponly 可以减轻 xss 攻击的危害，防止 cookie 被窃取，提高 cookie 的安全性。 secure: 用来设置 cookie 在 https 等安全协议下，cookie 才会被发送到服务端。默认情况下，不管是http、https 协议的请求都会把 cookie 发送到服务端。注意：只有是在 https 安全协议下的 web 站点，才能设置 secure 的 cookie; 只保证 cookie 与服务器之间的数据传输加密，而保存在本地的 cookie 文件并不加密。唯一一个非名值对儿，只包含 secure 一个单词例如：document.cookie = ‘_name=bai; secure’; cookie 的编码防止 cookie 的 key、 value 中含有空格、分号、等号特殊符号。所以 cookie 在设置时需要编码，获取时需要解码。编码、解码：escape/unescape encodeURIComponent/decodeURIComponent encodeURI/decodeURI可参考：cookie 编码介绍 js实现对cookie的增加、删除、修改1234567891011121314151617181920212223242526272829303132333435var dealCookie = &#123; // name, value, time(以年为单位), domain, path, secure, httponly(只能在服务端设置) set : function (json)&#123; var name = json.name, value = json.value, time = json.time, domain = json.domain, path = json.path, secure = json.secure, cookieStr = encodeURIComponent(name) + '=' + encodeURIComponent(value); if(time) cookieStr += '; expires=' + new Date(new Date().getTime() + time * 365 * 24 * 3600 * 1000).toGMTString(); if(domain) cookieStr += '; domain=' + domain; if(path) cookieStr += '; path=' + path; if(secure &amp;&amp; location.protocol.slice(0, -1) === 'https') cookieStr += '; secure'; document.cookie = cookieStr; &#125;, // 找到匹配项返回 get : function (name)&#123; var regArr = document.cookie.match( new RegExp('(\\s|^)' + encodeURIComponent(name) + '=([^;]*)(;|$)') ); return regArr ? decodeURIComponent(regArr[2]) : null; &#125;, // 当cookie的name/domain/path相同时，才可删除 unset : function (name, domain, path) &#123; var obj = &#123;&#125;; obj.name = name; obj.domain = domain; obj.path = path; obj.time = -1; dealCookie.set(obj); &#125;&#125;; 其他链接: 详解cookie localStorage 本地持久化存储，存储容量可达到5M以上，除非手动删除，否则一直存在。、 localStorage 存储的信息在同域内共享。受到同源策源影响，不能跨域。 localStorage 的数据也是以键值对儿形式存储，但不像cookie一样往返于客户端和服务端之间，避免浪费带宽。 localStoarge 一些属性、方法 localStorage.length; 获取localStorage的长度 localStorage.setItem(k, v); （可以适当使用JSON.stringify/JSON.parse） localStorage.getItem(k); localStorage.removeItem(k); 局部删除 localStorage.clear(); 全部删除 localStoarge 缺点 localStorage 是对字符串操作，如果存储数据很多，会消耗内存空间，使页面变卡。 localStorage 内的数据在隐私模式下不可读取。 localStorage 不会被爬虫爬取到，不要用它完全代替URL传参。 localStorage 的storage事件1window.addEventListener('storage', function(e)&#123;...&#125;, false); 需要注意的是： 在本页进行localStorage操作（新增、修改、删除）时，本业不会触发storage事件，但是别的页面会触发。在IE里面，本页面也会触发storage事件。 storage事件对象e有很多属性，重要的有。key、newValue、oldValue、url。 sessionStoarge 受同源策源的影响，数据只能在本标签页存储，不同窗口（标签页）的 sessionStoarge 数据不可共享。 有和localStoarge 相同的API，都是Storage类的实例。 sessionStoarge和localStorage的区别：持久化存储、窗口级别的存储。 indexDB]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象 OOP]]></title>
    <url>%2F2018%2F05%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP%2F</url>
    <content type="text"><![CDATA[对象对象是实物的抽象，也可以说它是一个容器，其中封装了属性和方法。 面向对象的特点面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。 构造函数工厂化的方式生成对象，如果实例对象属性、方法各不同，可放在构造函数内部。 如果有相同的属性、方法，那就直接把它们挂载在原型对象上。 构造函数内部机制（new 命令干了什么？） 创建了空的中间对象 将中间对象的原型 __proto__ 指向构造函数的 prototype 属性，this 指向中间对象。 执行构造函数内部代码，给中间对象挂载属性、方法。 隐式返回 this 。 123456789101112131415function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.showName = function() &#123; console.log(this.name); &#125;;Person.prototype.desc = '我是Person的原型!';console.log(new Person('Bob', 20));// new 操作符后干了什么???function personTemp(Fn, ...args) &#123; var obj = Object.create(Fn.prototype); // 创建了空对象，并把它的原型设置为构造函数的原型对象。 Fn.apply(obj, args); // 执行构造函数内部代码，改变this指向使其指向空对象，并给它挂载属性和方法。 return obj; // 返回挂载后的对象。&#125;console.log(personTemp('Bob', 20)); 构造函数返回值构造函数返回值默认是已经封装好了的 this 对象。如果返回基本类型，则返回值无效，相当于 new 命令会忽略这支语句，但是一旦返回 object 类型的数据，将会替代 this 。 12345678910111213function Demo1(name) &#123; this.name = name; return 'test'&#125;function Demo2(age) &#123; this.age = age; return [1,2,3]&#125;new Demo1('Bob') // &#123;name: Bob&#125;new Demo2(20) // [1,2,3] 原型每个函数都有 prototype 属性,该属性值是一个对象，即原型对象。原型对象出现的原因是挂载实例的公共属性和方法，减少创建每个实例的内存消耗。原型内部有一属性是指向构造函数的 constructor 。通过构造函数访问到原型对象：构造函数.prototype 实例对象访问原型对象实例对象.__proto__ 或者 Object.getPrototypeOf(实例对象)（推荐）综上,有一个恒等式; 实例对象.__proto__ === 构造函数.prototype 函数对象的原型函数不仅含有 prototype 属性，同时它也是对象，是 Function 实例化的结果。有如下结论： 123456var Test = function() &#123; alert(1); &#125;;Test.__proto__ === Function.prototype // trueTest.prototype.__proto__ === Object.prototype; // trueFunction.prototype === Fucntion.__proto__ // trueFunction.__proto__.prototype // undefinedFunction.__proto__.__proto__ // Object.prototype 原型链每个实例化对象都有原型，而原型又是对象，也能找到原型，一直寻找原型至 Object.prototype （它的原型为null）结束。 123var oTest = new Test();oTest.__proto__.__proto__ === Object.prototype // trueObject.prototype.__proto__ // null in、for-inin 判断对象是否含有某个属性，for-in 遍历属性如果在该对象并未找，它会顺着原型链查找，一直找到源头 Object.prototype 下的属性、方法，没有则返回 undefined，通常继承会利用这种特性；for-in 遍历对象及其祖先的可枚举、非 Symbol 属性时，如果只遍历自身的属性、方法，可以使用 Object.hasOwnProperty(obj) 来实现过滤。 另外，可用 isPrototypeOf 来判断该对象是否式参数的原型对象。 继承子类拥有父类的属性和方法，但是不对其进行更改，且每个子类实例互不影响。 构造函数继承构造函数继承又称类继承，意思是在子类的构造函数内部调用父类的构造函数（期间修改this指向）。 123456789101112131415function Parent(name) &#123; this.name = name;&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); // 构造方法继承的关键处 this.age = age; this.sex = sex;&#125;var child = new Child('Bob', 20, '男');child.showName(); // 报错 可以实现对父类属性、方法的继承。但是却继承不到父类原型上的属性、方法。 原型继承通过prototype实现原型继承，将子类原型对象指向父类的一个实例。 1234567891011121314151617181920function Parent(name) &#123; this.name = name; this.num = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child(20, '男');var child1 = new Child(21, '女');child.num.push(4);child1.num // [1,2,3,4]child.name // undefined 缺点：如果父类上存在引用类型的数据，一旦一个子类对其改变，其他子类的数据同样改变; 子类无法改变父类内部属性值，即使父类需要参数也不能传参，一旦传参，所有实例含有相同属性值。 组合继承继承父类、原型上的属性及其方法 123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 缺点是：调用了两次父类的构造函数。第一次为了继承父类的属性、方法。第二次是为了继承父类原型上的属性、方法，那何必不直接将子类原型指向父类的原型呢？ 在子类遍历属性时，岂不更快吗？ 不用创建父类实例，岂不更节约空间？ 组合继承的优化123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Parent.prototype; Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 似乎已经完美地继承了父类且所有子类实例可以共享父类原型的属性方法。但是，没办法知道子类的父类是谁啊？另外，子类和父类共用一个prototype，一旦子类修改了prototype，父类的prototype也会修改(比如constructor)。 最终的组合优化1234567891011121314151617181920212223242526272829function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child );/* 如果不支持Object.create(): if(!Object.create) &#123; Object.create = function(obj) &#123; function Fn() &#123;&#125;; Fn.prototype = obj; return new Fn(); &#125;; &#125;*/ Object.create(Parent.prototype)：以父类的原型为原型来创建一个空对象，子类原型指向这个空对象。这样就可以很清楚地看到子类地父类。 获取父类名：实力对象.__proto__.__proto__.constructor.name es6实现继承123456789101112131415161718192021222324class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; console.log( this.name ); &#125;&#125;class Child extends Parent &#123; constructor(name, age, sex) &#123; super(name); this.age = age; this.sex = sex; &#125; getAge() &#123; console.log( this.age ); &#125;&#125;var child = new Child('Bob', 20, '男');console.log( child );]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js 面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js获取DOM节点]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8E%9F%E7%94%9Fjs%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[获取DOM元素通过元素ID获取受到ID唯一性的限制，只能获取一个元素； 兼容所有浏览器 1document.getElementById('el-id') 通过元素的类名获取获取 obj 对象下的含有该类名的所有元素，返回一个类数组 HTMLCollection； 不兼容ie8- 1obj.getElementsByClassName('el-className') 通过标签获取obj 对象下是该标签的节点，返回一个类数组 HTMLCollection； 兼容所有浏览器。 1obj.getElementsByTagName('el-name') H5新增获取元素的Api，不兼容ie7-可获取单个节点、多个节点, 返回的是 NodeList 类数组 12obj.querySelector('选择器') obj.querySelectorAll('选择器') children 获取获取对象obj下第index（index是非负整数）个子元素 1obj.children[index] 动态获取和静态获取动态获取获取的可以是 HTMLCollection、动态节点。DOM元素进行添加、修改删除子元素，该动态列表也会相应的更新，可看做 HTMLCollector 是 DOM 节点的引用。 对应的动态方法： obj.getElementsByTagName(‘el-name’) obj.getElementsByClassName(‘el-className’) obj.children[index] 静态获取获取的可以是 NodeList、静态节点。DOM 元素进行添加、修改删除子元素，该动态列表不会更新，可看做 HTMLCollector 是 DOM 节点的复制。通常来说，静态方法会比动态方法慢。 对应的动态方法： obj.querySelector(‘选择器’) obj.querySelectorAll(‘选择器’) jq获取的节点列表、对象，jq的获取类似于querySelector 举个栗子来表明以上两种获取方式1234567891011121314151617181920212223242526272829303132&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;!function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.getElementsByTagName('li'); console.log( aLi.length ); // 6 oUl.removeChild(aLi[aLi.length - 1]); /*父元素把最后一个li对象删除，aLi发生变化*/ console.log( aLi.length ); // 5&#125;();+function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.querySelectorAll('li'); console.log( aLi.length ); // 5 var oLi = document.createElement('li'); oUl.appendChild(oLi); /*父元素在最后添加一个li对象,aLi无变化*/ console.log( aLi.length ); // 5&#125;(); &lt;/script&gt; 遍历类数组先把类数组 HTMLCollection、NodeList、arguments 转换成数组，再使用数组方法遍历： 123456789101112131415161718192021&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var aLi = document.querySelectorAll('li'); [].slice.call(aLi).forEach((oLi, index) =&gt; &#123;console.log( oLi, index );&#125;); [...aLi].forEach((oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); Array.from(aLi, (oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原生js获取DOM节点</tag>
      </tags>
  </entry>
</search>
