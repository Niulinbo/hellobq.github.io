<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue 全局API]]></title>
    <url>%2F2018%2F06%2F07%2FVue-%E5%85%A8%E5%B1%80API%2F</url>
    <content type="text"><![CDATA[全局 API不在构造器内部、挂载在构造函数 Vue 下的 API，也就是 Vue 的静态方法。 Vue.directive自定义指令。实现对普通 DOM 元素底层操作。语法：Vue.directive({String}id, {funciton|object}defination)、`directives分类： 全局自定义指令 可用于所有 Vue 实例 局部自定义指令 仅仅作用于当前组件 自定义指令的钩子函数: bind 只调用一次，指令第一次绑定到元素上调用。用来初始化设置。 inserted 被绑定的元素插入到父节点时调用（要保证父节点存在）。 update 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind 只调用一次，指令与元素解绑时调用。 每个自定义指令钩子函数的内部参数（直接拷贝官网上的）: el 绑定的 DOM 元素，可读。 binding 包含众多属性的对象: name 指令名，不包含 v- 前缀。 value 指令绑定值，通常是 string、json格式。 oldValue 指令绑定的前一个值，仅在 update、componentUpdated钩子中使用。无论值是否改变都可用。 expression 字符串形式的指令表达式。例如：v-mydirective=&quot;1 + 1&quot;, expression 就是 1 + 1。 arg 传给指令的参数，可选。例如：v-mydirective:foo, arg就是foo。 modifiers 一个包含修饰符的对象。例如：v-my-directive.foo.bar，修饰符对象是：{foo: true, bar: true} VNode Vue编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldNode 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中使用。 1234567891011121314151617181920212223242526272829303132/*HTML &lt;div id="wrap"&gt; &lt;input type="text" v-demo:foo.bar.lala="1 + 1" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;textarea v-focus&gt;&lt;/textarea&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;, directives: &#123; demo: &#123; inserted(el, binding, VNode) &#123; console.log(el); // &lt;input type="text"&gt; console.log(binding.name); // focus console.log(binding.value); // 2 console.log(binding.expression); // 1 + 1 console.log(binding.arg); // foo console.log(binding.modifiers); // &#123;bar: true, lala: true&#125; &#125; &#125;, focus: &#123; inserted(el) &#123; el.focus(); &#125; &#125; &#125;&#125;); Vue.extendvue 扩展构造器。主要来服务 Vue.component 来创建全局组件。语法：Vue.extend({object}options)需要注意的是： 组件和主组件有一点很大不同：data 选项必须是函数类型，且要返回 json 类型。（防止因为组件复用时，一数据变化其他也会变化）。 该全局 API 的模板选项会覆盖挂载点。 123456789101112131415/*HTML &lt;div id="wrap"&gt;&lt;/div&gt;*/var myExtend = Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; msg: 'Vue.extend demo!' &#125; &#125;&#125;);new myExtend().$mount('div'); Vue.filter过滤器。用来简单过滤后台请求的数据。语法：Vue.filter({string}id, {function}defination)、filters注意： 过滤器的 function 选项第一个参数是被过滤的数据。 多过虑器（前一个过滤器返回值作为后一个过滤器的第一个参数），用 | 隔开。 12345678910111213141516171819202122/*HTML &lt;div id="wrap"&gt;&#123;&#123;msg | msgReverse(flag)&#125;&#125;&lt;/div&gt; 全局过滤器 Vue.filter('msgReverse', function(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125;);*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;, filters: &#123; // 局部过滤器 msgReverse(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125; &#125;&#125;); Vue.component全局注册组件，相对于局部组件不需要引入。语法： Vue.component({string}id, {object|function}defination)。 12345678910111213141516171819202122232425262728293031323334/* HTML&lt;div id="wrap"&gt; &lt;my-component1&gt;&lt;/my-component1&gt; &lt;my-component2&gt;&lt;/my-component2&gt;&lt;/div&gt;*/Vue.component('my-component1', Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;));// 实现同样的功能，第二个参数直接使用 &#123;&#125; 形式，比 Vue.extend 更高效、简洁!Vue.component('my-component2', &#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;&#125;); Vue.use引入组件（插件）。语法：Vue.use({object|function}plugin) 123456// 先使用require引入通过npm安装的包，在Vue对象上引入插件。 var VueRouter = require('vue-router'), Vue = require('vue'), VueAwesomeSwiper = require('vue-awesome-swiper');Vue.use(VueRouter).use(VueAwesomeSwiper)....]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 全局API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 内部指令]]></title>
    <url>%2F2018%2F06%2F06%2FVue-%E5%86%85%E9%83%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-text更新元素的 innerText，但不会渲染带有标签的字符串。 1234567891011/*HTML &lt;div v-text="msg"&gt;&lt;/div&gt; // 如同模板字符串 &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; */var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;&#125;); 使用 v-text 内部指令和使用模板字符串看似效果一样，但是当网速慢导致 data 未编译成功时，v-text 就不会将 msg 渲染出；但是模板字符串却很尴尬的暴露出来了，这时需要使用 v-cloak 了。 v-html更新元素的 innerHTML ，如果在前端操作该 innerHTML（复杂 HTML），通常把它作为组件剥离出去。当然也可以直接动态渲染可信的 HTML 。渲染未知来源（用户提供的内容）的 HTML 这是非常危险的，因为容易受到 xss 攻击。 1234567891011/*HTML &lt;div v-html="msg"&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: '&lt;p&gt;hello world!&lt;/p&gt;' &#125;&#125;); v-show条件渲染。根据表达式来改变data 内部数据值的真假，从而来改变元素 css 中 display属性。 12345678910111213141516/*HTML&lt;div id="wrap"&gt; &lt;div v-show="flag"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click="flag = !flag"&gt;toggle show&lt;/button&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;&#125;); v-if v-else v-else-if条件渲染。根据表达式来改变data 内部数据值的真假，从文档中清除/显示指定元素，和 v-show 不同的是，它并不通过改变元素 css 中 display属性来控制元素的显示隐藏，而是直接动态添加/删除元素。v-else 必须在 v-if/v-else-if 后面; v-else-if 前面必须有 v-if/v-else 1234567891011121314151617/*HTML&lt;div id="wrap"&gt; &lt;div v-if="isMan"&gt;I am a man!&lt;/div&gt; &lt;div v-else-if="isAlice"&gt;I am Alice!&lt;/div&gt; &lt;div v-else&gt;I am a woman!&lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; isMan: false, isAlice: false &#125;&#125;); v-for列表渲染。遍历并渲染 array、object、number、string。更多的是遍历 json 数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*HTML&lt;div id="wrap"&gt; &lt;div class="demo-string"&gt; &lt;ul&gt; &lt;li v-for="(ch, index) in str" :key="index"&gt;&#123;&#123;ch&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-number"&gt; &lt;ul&gt; &lt;li v-for="(n, index) in arr" :key="index"&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json-arr"&gt; // important! &lt;ul&gt; &lt;li v-for="item in jsonArr" :key="item.id"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json"&gt; &lt;p v-for="item in myJson"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; str: 'abcdefg', arr: [1,2,3,4,5], jsonArr: [&#123; id: 1, name: 'Bob' &#125;, &#123; id: 2, name: 'Alice' &#125;, &#123; id: 3, name: 'Jack' &#125;], myJson: &#123; name: 'Facker', age: 20, sex: '男' &#125; &#125;&#125;); 可注意到：使用 v-for 渲染列表时，Vue 建议给每一项绑定一个唯一 key 属性，它用来保证数据的唯一性，如果有相同的 key 值，将会导致渲染错误。 v-on事件监听。简写成 @, 分为两类： 用在普通 HTML 元素上来监听 DOM 事件。实现相关的逻辑处理功能。 用在自定义元素组件上来监听子组件触发的自定义事件，从而实现子组件通过事件流的方式向父组件传递消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*HTML&lt;div&gt; &lt;button @click="fn1"&gt;按钮1&lt;/button&gt; &lt;button @click="fn2('haha', $event)"&gt;按钮2&lt;/button&gt; &lt;my-component @my-event='fn3'&gt;&lt;/my-component&gt; &lt;!-- 子组件触发my-event自定义事件时，父组件执行fn3函数。注意此时形参中的$event不再是事件对象event，而是子组件向父组件传递的信息。 但是在实参处写$event也没意义，因为可以在形参接受到全部消息 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button @click="toParentMsg"&gt;子组件按钮!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; toParentMsg() &#123; this.$emit('my-event', this.msg, 'gogo'); // 按钮点击时，触发自定义事件my-event &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn1(event) &#123; // 监听DOM事件，如果无实参则methods中对应函数的第一个形参是事件对象event console.log(event); &#125;, fn2(str, event) &#123; // 监听DOM事件，如果有实参则使用$event向形参传递事件对象event console.log( str, event ); &#125;, fn3(str1, str2) &#123; // 监听子组件my-event事件 console.log( str1, str2 ); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); 事件修饰符: 对事件的附加修饰。 .prevent 阻止默认事件 .stop 阻止事件冒泡 .native 监听根组件的原生事件。用来自定义元素组件触发原生事件时，调用根组件内部函数。 还有其他事件修饰符… Vue 官网 123456789101112131415161718192021222324252627282930313233343536373839// .native demo/*HTML&lt;div&gt; &lt;my-component @click.native="fn"&gt;&lt;/my-component&gt; &lt;!-- 注意：事件是绑定在自定义元素组件上的，而不是子组件模板中的普通元素上，否则会调用子组件内部的fn方法 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button&gt;点击试试!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; fn() &#123; console.log('hahaha'); &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn() &#123; console.log('lalala'); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); v-bind绑定 DOM 属性，分为： 绑定合法属性，属性值是 data 内部的值。 绑定自定义属性，通过 props 实现父组件向子组件传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 以绑定 class、style 两个合法属性为例/*css.classA &#123; width: 100px; height: 100px; &#125;.classB &#123; background: skyblue; border-radius: 2px;&#125;*//*HTML&lt;div id="wrap"&gt; &lt;!-- 绑定 style --&gt; &lt;div :style="&#123; width: width + 'px', height: height + 'px', borderRadius: borderRadius + 'px', background: bgColor &#125;"&gt; &lt;/div&gt; &lt;div :style="styleObj"&gt;&lt;/div&gt; &lt;div :style="[styleObj1, styleObj2]"&gt;&lt;/div&gt; &lt;!-- 绑定 class --&gt; &lt;div :class="&#123; classA: 'classA', classB: 'classB' &#125;"&gt; &lt;/div&gt; &lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!', width: 100, height: 100, borderRadius: 2, bgColor: 'pink', styleObj: &#123; width: '100px', height: '100px', background: 'pink' &#125;, styleObj1:&#123; width: '100px', height: '100px' &#125;, styleObj2:&#123; background: 'skyblue', borderRadius: '2px' &#125;, classA: 'classA', classB: 'classB' &#125;&#125;);// 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。/*HTML&lt;div id="wrap"&gt; &lt;my-component :to-child="msg"&gt;&lt;/my-component&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt; &lt;h4&gt;这是子组件!&lt;/h4&gt; &lt;p&gt;父组件向子组件传递的消息是--&#123;&#123;toChild&#125;&#125;&lt;/p&gt; // 传递过来的消息在子组件模板中得到应用 &lt;/div&gt;`, props: ['toChild'] &#125; &#125;&#125;); 总结： 绑定多个内敛样式不如动态添加 class，动态添加 class 使用对象形式更方便。 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。极其重要！ v-model双向绑定。在表单控件 input、textarea、select或组件 components 上创建双向绑定。v-model 修饰符： .lazy 用表单的 change 事件代替 input 事件。 .trim 过滤掉首位空格。 .number 将字符串格式的 value 转换成数字。 v-model 仅是语法糖，负责监听用户的输入事件 input 来更新数据。底层一点: v-model 是靠 v-bind 对 value 值的绑定和监听表单 input 事件。 123456789101112131415161718192021222324/*HTML&lt;div id="wrap"&gt; &lt;!-- &lt;input type="text" v-model="msgInput"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; 等同下面--&gt; &lt;input type="text" :value="msgInput" @input="msgInput = $event.target.value"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; &lt;!-- 组件上的双向绑定就是父子组件的通信过程 props、$emit --&gt; &lt;my-component v-model="msgComponent"&gt;&lt;/my-component&gt;&lt;p&gt;&#123;&#123;msgComponent&#125;&#125;&lt;/p&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msgInput: 'hello world!', msgComponent: 'my msg from component!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;input type="text" :value="value" @input="$emit('input', $event.target.value)"/&gt;`, props: ['value'] &#125; &#125;&#125;); v-pre跳过编译，显示原来的插值样式。123456789101112/*HTML&lt;div id="wrap" v-pre&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; // 不显示 hello 而是 &#123;&#123;msg&#125;&#125;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-cloak避免实例未准备好而出现插值样式的尴尬页面。需要和 css 样式一同使用。1234567891011121314151617181920/*css[v-cloak] &#123; display: none;&#125;*//*HTML&lt;div id="wrap" v-cloak&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-once单次渲染元素/组件后，元素/组件及其子节点全部作为静态内容不会被刷新渲染。对低开销的静态组件使用 v-once 指令可以优化性能。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 内部指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语义化标签、css3新增选择器、css3新增样式]]></title>
    <url>%2F2018%2F06%2F04%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[什么是语义化很容易让编程人员、浏览器读懂代码的内容。 语义化的优点 页面结构更清晰，容易将网页分块，更便于开发维护 有利于搜索引擎的抓取能力、SEO 优化。 html5 新增常用的标签兼容性：ie9+ header : 网站头部，或者一个局域块的头部。 article : 定义一片文本区域，盛放文章等内容，常用在帖子、博客文章、评论、新闻。 nav： 盛放导航的盒子，链接排列。nav &gt; ul &gt;li &gt; a section : 局域块。article 专门盛放文本的，它可以盛放其他东西。 aside : 侧边栏，窗口左右边的能点击的锚点小块。 footer : 网站尾部，或者一个局域块的尾部。 figure : 展示图片及其描述。figcaption 定义 figure 的标题，它不能单独使用。 mark : 标记小部分内容。默认背景色是黄色，可用js改变。 canvas、svg、video、audio 等高级 h5 标签。 css3新增选择器属性选择器 E[attr] : 选择具有属性attr的E元素 E[attr = &#39;val&#39;] : 选择具有属性 attr、attr 值为 val 的E元素。 E[attr ~= &#39;val&#39;] : 选择具有属性 attr 、属性值中有一个（可能有几个属性值，它们以空格隔开）是 val 的E元素。 E[attr ^= &#39;val&#39;] : 选择具有属性attr、属性值以 val 开头的字符串的E元素，如果有多个属性值，只检测第一个值。 E[attr $= &#39;val&#39;] : 选择具有属性 attr、属性值以 val 结尾的字符串的E元素，如果有多个属性值，只检测最后一个值。 E[attr |= &#39;val&#39;] : 选择具有属性 attr、属性值是 val 或者 val 用 - 链接的的E元素。eg: div.[class |= ‘h’] E[attr *= &#39;val&#39;] : 选择具有属性 attr 、属性值包含 val 的字符串的E元素。 伪类选择器： E:first-child : 匹配父元素中第一个子元素、且元素种类为E。 E: last-child : 匹配父元素中最后一个子元素、且元素种类为E。 E:first-of-type : 匹配父元素中类型为E的第一个元素。 E:last-of-type : 匹配父元素类型中为E的最后一个元素。 E:nth-child(n) : 匹配父元素中第n个元素、元素类型为E。 E:nth-last-child(n) : 倒着数，匹配父元素中第n个、类型为E的元素。 E:nth-of-type(n) : 匹配父元素中第n个、类型为E的子元素。 E:nth-last-of-type(n): 倒着数，匹配父元素中第n个元素。 E:empty : 匹配没有内容的E元素。这里没有内容，指的是 innerHTML 为空、可以有 before、after E:target : 被锚点激活的E元素，某个元素的ID值是a链接的 href ，并且在前面加上#。例如：&lt;div id=&#39;box&#39;&gt;&lt;/div&gt; &lt;a href=&#39;#box&#39;&gt;&lt;/a&gt; 两个栓在一起。当鼠标点击a时候，div就会触发:target伪类样式。 E:checked: 已被选择的单、多选按钮。 E:enabled : 匹配可用状态的表单元素E。 E:disabled : 匹配不能使用的表单元素E。 E:not(选择器) : 匹配不包含指定选择器的元素 E:focus : 匹配获得焦点的元素E。 伪元素选择器： E::after : 选择E的伪元素 after E::before : 选择E的伪元素 before content 不能省，默认是内联元素，通常需要定位。 E::placeholder : 修饰表单元素E里面的 placeholder 属性值的样式。通常放在 input 里面，起到提示作用，当点击 input 时候，placeholder 仍然出现。通常 placeholder 是通过js模拟。 E::selection : 鼠标选择的样式（背景、color、text-shadow）。 E::first-letter : 第一个文字。 E::first-line : 第一行 伪类、伪元素注意点 对空元素添加 ::before ::after伪元素后，:empty 伪类还是有作用的。 两个伪元素::before ::after 通常和动画、转换、过度结合。实现图片层叠效果、达到节约元素的目的。 nth-child、nth-of-type 里面可以写： 数字、英文、类似 ab + b 表达式。 伪元素和伪类的区别伪类是直接给元素添加样式。伪元素是先添加元素再去定义样式。 css3 新增属性新增边框属性 border-radius : 设置边框圆角。分为水平方向和竖直方向上的圆角设置，用/隔开。 IE9+ box-shadow : 添加盒子阴影。多个阴影用 , 隔开。 IE9+ border-image : 用图片绘画边框（很少用）。 新增背景属性 background-clip 、 background-origin 、background-break。用的少。 background-size : cover | contain | auto | 具体长度、宽度。设置背景大小，通常也是考虑到背景图的大小来设置盒子大小（不是雪碧图）。 cover : 保证背景会覆盖盒子，但是可能背景不完全显示。 contain : 能等比缩放到盒子的边或者宽，但是不一定会完全覆盖盒子。 背景的复合写法：background: [其他颜色] background-image [background-repeat background-position / background-size]; 多背景用逗号隔开。 新增的文本效果 white-space : normal | nowrap | pre | pre-wrap 规定 空格、换行、缩进的处理方式。使超出文本出现省略号：white-space: nowrap; overflow: hidden; text-overflow:ellipsis; word-wrap : normal | break-word 对单词是否拆分。 text-shadow : 文本阴影。规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-full-color : 设置文字填充色。个人觉得和 color 并无区别。 text-stroke-color : 设置文本描边色。 text-stroke-width : 设置文字边界宽度。 更多的css3新增属性具体参见：css手册]]></content>
      <categories>
        <category>h5</category>
      </categories>
      <tags>
        <tag>h5 语义化标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this 指向]]></title>
    <url>%2F2018%2F05%2F26%2Fthis-%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this 指向情形如下： 全局下的 this 指向 对象字面量内部 构造函数内部 call、apply、bind 手动改变 this 指向 es6箭头函数内部 全局下的 this 指向在浏览器中，全局下的 this 指向 window 对象；在 node 环境中，则指向 global 对象。 1234var fn = function() &#123; console.log( this ); &#125;; // windowfn(); // 等同this.fn()、window.fn()console.log( this ); //window 对象字面量内部的 this 指向很容易认为 this 就是指向该对象字面量，其实这种情况只是其中之一。正确的判断出 this 指向需要看哪个对象直接调用了函数。 12345678910111213141516var age = 0; var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;var fn = obj2.getAge = obj1.getAge;fn(); // window.fn() 0obj2.getAge(); // 2 构造函数内部的 this 指向通过 new 命令的执行机制，知道构造函数内部的 this 就是指向创建出的实例。 12345678910111213141516171819function Person(name, age, sex) &#123; var a = 0; function sss() &#123; // 闭包 a ++; console.log(a); &#125; this.say = sss; this.name = name; this.age = age; this.sex = sex;&#125;var oPersopn = new Person('Bob', 20, '男');oPersopn.say(); // 1oPersopn.say(); // 2var oPersopn1 = new Person('Alice', 18, '女');oPersopn1.say(); // 1 call、apply、bind 手动改变 this 指向函数内部 this 就是使用 call、apply 、bind 调用函数时第一个参数。以 call 为例： 123456789101112var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;obj1.getAge.call(obj2); // 2 es6箭头函数内部 this 指向记住它和父级作用域的 this 一致。 123456789101112131415161718var age = 0;var obj = &#123; age: 1, getAge1: function() &#123; setTimeout(function() &#123; console.log( this.age ); &#125;); &#125;, getAge2: function() &#123; setTimeout(() =&gt; &#123; console.log( this.age ); &#125;); &#125;&#125;obj.getAge1(); // 0obj.getAge2(); // 1 一道经典面试题1234567891011121314var a = 10;var foo = &#123; a: 20, bar: function()&#123; var a = 30; console.log( this.a ); &#125;&#125;foo.bar(); // 20 没毛病(foo.bar)(); // 20 匿名函数自执行，但该函数仅限于foo对象中的变量使用。等同于foo.bar()(foo.bar, foo.bar)(); // 10 逗号运算符，返回最右边的表达式。匿名函数自执行,this指向window(foo.bar = foo.bar)(); // 10 foo.bar被重新赋值一个函数，然后再执行这个匿名函数，但是此时的函数被赋值之后，this指向了全局变量window]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>this 指向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前端存储方式 cookie localStorage sessionStorage indexDB (待续) cookie cookie 运行在服务器端，存放在客户端（用户浏览器）。 cookie 是绑定在域名上的。不同域名存放的 cookie 位置和内容不同。cookie 能够在同个域名多页面使用，但正常情况下，不能跨域使用。 不同浏览器的 cookie 存储位置不同，更不能相互使用。 cookie 存放内容空间很小，不同浏览器存放大小不同，一般4KB左右，20个左右。 cookie 默认无效时间是会话结束。当用户关闭浏览器时就会失效。 cookie 安全性不高，别人能够拿到本地 cookie 然后进行 cookie 欺骗。 cookie 作用：实现身份验证、保存用户登陆信息、信息跟踪等。 cookie 的工作原理当页面每次发送 http 请求时，浏览器都会携带与目标 URL（domain+path） 相关的 cookie 信息。有则自动会添加到 request cookie 中（即使不需要某一 cookie。 所以，cookie 大小不宜太大），伴随着 http 请求发送到服务器。 cookie 的属性name value domain path expires/max-age httponly secure 等。 name value: cookie 的键值对儿。 domain: 控制 cookie 对那个域有效。默认值是创建 cookie 时所在网页的域名。即 URL 中的 host。 手动设置 cookie 的域的话，可以设置 domain 为本域、父域，不能是公共后缀。如：本域为 www.google.com.hk 。可以将 domain 设置为 www.google.com.hk、google.com.hk，但是不能设置为 .com.hk com.hk .hk 等。 path: 控制 cookie 作用目录。默认是创建 cookie 的文件目录。这样 domain+path（即URL） 就决定了cookie 能够被哪些页面共享了。 expries/max-age: 规定 cookie 的过期时间。默认 cookie 的生存期是会话结束时, cookie 失效。expires 是一个时间点,单位毫秒； max-age 是一个以秒为时间的时间段。max-age 可能的值：负数(有效期为会话结束)、0(删除cookie)、正数(有效期为创建时刻 + 最大时间)。例如，设置过期时间是两年后过期：expires = new Date(new Date().getTime() + 2 365 24 3600 1000).toGMTString() 或者 max-age = 2 365 24 * 3600; httponly: 用来指定 cookie 能否通过js访问到。默认情况下，是可以通过js获取、更改、删除 cookie 的。cookie 设置 httpOnly 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。客户端不能通过js设置 httponly 值的，必须是服务端设置。好处是将 cookie 设置为 httponly 可以减轻 xss 攻击的危害，防止 cookie 被窃取，提高 cookie 的安全性。 secure: 用来设置 cookie 在 https 等安全协议下，cookie 才会被发送到服务端。默认情况下，不管是http、https 协议的请求都会把 cookie 发送到服务端。注意：只有是在 https 安全协议下的 web 站点，才能设置 secure 的 cookie; 只保证 cookie 与服务器之间的数据传输加密，而保存在本地的 cookie 文件并不加密。唯一一个非名值对儿，只包含 secure 一个单词例如：document.cookie = ‘_name=bai; secure’; cookie 的编码防止 cookie 的 key、 value 中含有空格、分号、等号特殊符号。所以 cookie 在设置时需要编码，获取时需要解码。编码、解码：escape/unescape encodeURIComponent/decodeURIComponent encodeURI/decodeURI可参考：cookie 编码介绍 js实现对cookie的增加、删除、修改1234567891011121314151617181920212223242526272829303132333435var dealCookie = &#123; // name, value, time(以年为单位), domain, path, secure, httponly(只能在服务端设置) set : function (json)&#123; var name = json.name, value = json.value, time = json.time, domain = json.domain, path = json.path, secure = json.secure, cookieStr = encodeURIComponent(name) + '=' + encodeURIComponent(value); if(time) cookieStr += '; expires=' + new Date(new Date().getTime() + time * 365 * 24 * 3600 * 1000).toGMTString(); if(domain) cookieStr += '; domain=' + domain; if(path) cookieStr += '; path=' + path; if(secure &amp;&amp; location.protocol.slice(0, -1) === 'https') cookieStr += '; secure'; document.cookie = cookieStr; &#125;, // 找到匹配项返回 get : function (name)&#123; var regArr = document.cookie.match( new RegExp('(\\s|^)' + encodeURIComponent(name) + '=([^;]*)(;|$)') ); return regArr ? decodeURIComponent(regArr[2]) : null; &#125;, // 当cookie的name/domain/path相同时，才可删除 unset : function (name, domain, path) &#123; var obj = &#123;&#125;; obj.name = name; obj.domain = domain; obj.path = path; obj.time = -1; dealCookie.set(obj); &#125;&#125;; 其他链接: 详解cookie localStorage 本地持久化存储，存储容量可达到5M以上，除非手动删除，否则一直存在。、 localStorage 存储的信息在同域内共享。受到同源策源影响，不能跨域。 localStorage 的数据也是以键值对儿形式存储，但不像cookie一样往返于客户端和服务端之间，避免浪费带宽。 localStoarge 一些属性、方法 localStorage.length; 获取localStorage的长度 localStorage.setItem(k, v); （可以适当使用JSON.stringify/JSON.parse） localStorage.getItem(k); localStorage.removeItem(k); 局部删除 localStorage.clear(); 全部删除 localStoarge 缺点 localStorage 是对字符串操作，如果存储数据很多，会消耗内存空间，使页面变卡。 localStorage 内的数据在隐私模式下不可读取。 localStorage 不会被爬虫爬取到，不要用它完全代替URL传参。 localStorage 的storage事件1window.addEventListener('storage', function(e)&#123;...&#125;, false); 需要注意的是： 在本页进行localStorage操作（新增、修改、删除）时，本业不会触发storage事件，但是别的页面会触发。在IE里面，本页面也会触发storage事件。 storage事件对象e有很多属性，重要的有。key、newValue、oldValue、url。 sessionStoarge 受同源策源的影响，数据只能在本标签页存储，不同窗口（标签页）的 sessionStoarge 数据不可共享。 有和localStoarge 相同的API，都是Storage类的实例。 sessionStoarge和localStorage的区别：持久化存储、窗口级别的存储。 indexDB]]></content>
      <categories>
        <category>javascript</category>
        <category>h5</category>
      </categories>
      <tags>
        <tag>本地存储</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象 OOP]]></title>
    <url>%2F2018%2F05%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP%2F</url>
    <content type="text"><![CDATA[对象对象是实物的抽象，也可以说它是一个容器，其中封装了属性和方法。 面向对象的特点面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。 构造函数工厂化的方式生成对象，如果实例对象属性、方法各不同，可放在构造函数内部。 如果有相同的属性、方法，那就直接把它们挂载在原型对象上。 构造函数内部机制（new 命令干了什么？） 创建了空的中间对象 将中间对象的原型 __proto__ 指向构造函数的 prototype 属性，this 指向中间对象。 执行构造函数内部代码，给中间对象挂载属性、方法。 隐式返回 this 。 构造函数返回值构造函数返回值默认是已经封装好了的 this 对象。如果返回基本类型，则返回值无效，相当于 new 命令会忽略这支语句，但是一旦返回 object 类型的数据，将会替代 this 。 12345678910111213function Demo1(name) &#123; this.name = name; return 'test'&#125;function Demo2(age) &#123; this.age = age; return [1,2,3]&#125;new Demo1('Bob') // &#123;name: Bob&#125;new Demo2(20) // [1,2,3] 原型每个函数都有 prototype 属性,该属性值是一个对象，即原型对象。原型对象出现的原因是挂载实例的公共属性和方法，减少创建每个实例的内存消耗。原型内部有一属性是指向构造函数的 constructor 。通过构造函数访问到原型对象：构造函数.prototype 实例对象访问原型对象实例对象.__proto__ 或者 Object.getPrototypeOf(实例对象)（推荐）综上,有一个恒等式; 实例对象.__proto__ === 构造函数.prototype 函数对象的原型函数不仅含有 prototype 属性，同时它也是对象，是 Function 实例化的结果。有如下结论： 123456var Test = function() &#123; alert(1); &#125;;Test.__proto__ === Function.prototype // trueTest.prototype.__proto__ === Object.prototype; // trueFunction.prototype === Fucntion.__proto__ // trueFunction.__proto__.prototype // undefinedFunction.__proto__.__proto__ // Object.prototype 原型链每个实例化对象都有原型，而原型又是对象，也能找到原型，一直寻找原型至 Object.prototype （它的原型为null）结束。 123var oTest = new Test();oTest.__proto__.__proto__ === Object.prototype // trueObject.prototype.__proto__ // null in、for-inin 判断对象是否含有某个属性，for-in 遍历属性如果在该对象并未找，它会顺着原型链查找，一直找到源头 Object.prototype 下的属性、方法，没有则返回 undefined，通常继承会利用这种特性；for-in 遍历对象及其祖先的可枚举、非 Symbol 属性时，如果只遍历自身的属性、方法，可以使用 Object.hasOwnProperty(obj) 来实现过滤。 另外，可用 isPrototypeOf 来判断该对象是否式参数的原型对象。 继承子类拥有父类的属性和方法，但是不对其进行更改，且每个子类实例互不影响。 构造函数继承构造函数继承又称类继承，意思是在子类的构造函数内部调用父类的构造函数（期间修改this指向）。 123456789101112131415function Parent(name) &#123; this.name = name;&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); // 构造方法继承的关键处 this.age = age; this.sex = sex;&#125;var child = new Child('Bob', 20, '男');child.showName(); // 报错 可以实现对父类属性、方法的继承。但是却继承不到父类原型上的属性、方法。 原型继承通过prototype实现原型继承，将子类原型对象指向父类的一个实例。 1234567891011121314151617181920function Parent(name) &#123; this.name = name; this.num = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child(20, '男');var child1 = new Child(21, '女');child.num.push(4);child1.num // [1,2,3,4]child.name // undefined 缺点：如果父类上存在引用类型的数据，一旦一个子类对其改变，其他子类的数据同样改变; 子类无法改变父类内部属性值，即使父类需要参数也不能传参，一旦传参，所有实例含有相同属性值。 组合继承继承父类、原型上的属性及其方法 123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 缺点是：调用了两次父类的构造函数。第一次为了继承父类的属性、方法。第二次是为了继承父类原型上的属性、方法，那何必不直接将子类原型指向父类的原型呢？ 在子类遍历属性时，岂不更快吗？ 不用创建父类实例，岂不更节约空间？ 组合继承的优化123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Parent.prototype; Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 似乎已经完美地继承了父类且所有子类实例可以共享父类原型的属性方法。但是，没办法知道子类的父类是谁啊？另外，子类和父类共用一个prototype，一旦子类修改了prototype，父类的prototype也会修改(比如constructor)。 最终的组合优化1234567891011121314151617181920212223242526272829function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child );/* 如果不支持Object.create(): if(!Object.create) &#123; Object.create = function(obj) &#123; function Fn() &#123;&#125;; Fn.prototype = obj; return new Fn(); &#125;; &#125;*/ Object.create(Parent.prototype)：以父类的原型为原型来创建一个空对象，子类原型指向这个空对象。这样就可以很清楚地看到子类地父类。 获取父类名：实力对象.__proto__.__proto__.constructor.name es6实现继承123456789101112131415161718192021222324class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; console.log( this.name ); &#125;&#125;class Child extends Parent &#123; constructor(name, age, sex) &#123; super(name); this.age = age; this.sex = sex; &#125; getAge() &#123; console.log( this.age ); &#125;&#125;var child = new Child('Bob', 20, '男');console.log( child );]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js 面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js获取DOM节点]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8E%9F%E7%94%9Fjs%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[获取DOM元素通过元素ID获取受到ID唯一性的限制，只能获取一个元素； 兼容所有浏览器 1document.getElementById('el-id') 通过元素的类名获取获取 obj 对象下的含有该类名的所有元素，返回一个类数组 HTMLCollection； 不兼容ie8- 1obj.getElementsByClassName('el-className') 通过标签获取obj 对象下是该标签的节点，返回一个类数组 HTMLCollection； 兼容所有浏览器。 1obj.getElementsByTagName('el-name') H5新增获取元素的Api，不兼容ie7-可获取单个节点、多个节点, 返回的是 NodeList 类数组 12obj.querySelector('选择器') obj.querySelectorAll('选择器') children 获取获取对象obj下第index（index是非负整数）个子元素 1obj.children[index] 动态获取和静态获取动态获取获取的可以是 HTMLCollection、动态节点。DOM元素进行添加、修改删除子元素，该动态列表也会相应的更新，可看做 HTMLCollector 是 DOM 节点的引用。 对应的动态方法： obj.getElementsByTagName(‘el-name’) obj.getElementsByClassName(‘el-className’) obj.children[index] 静态获取获取的可以是 NodeList、静态节点。DOM 元素进行添加、修改删除子元素，该动态列表不会更新，可看做 HTMLCollector 是 DOM 节点的复制。通常来说，静态方法会比动态方法慢。 对应的动态方法： obj.querySelector(‘选择器’) obj.querySelectorAll(‘选择器’) jq获取的节点列表、对象，jq的获取类似于querySelector 举个栗子来表明以上两种获取方式1234567891011121314151617181920212223242526272829303132&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;!function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.getElementsByTagName('li'); console.log( aLi.length ); // 6 oUl.removeChild(aLi[aLi.length - 1]); /*父元素把最后一个li对象删除，aLi发生变化*/ console.log( aLi.length ); // 5&#125;();+function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.querySelectorAll('li'); console.log( aLi.length ); // 5 var oLi = document.createElement('li'); oUl.appendChild(oLi); /*父元素在最后添加一个li对象,aLi无变化*/ console.log( aLi.length ); // 5&#125;(); &lt;/script&gt; 遍历类数组先把类数组 HTMLCollection、NodeList、arguments 转换成数组，再使用数组方法遍历： 123456789101112131415161718192021&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var aLi = document.querySelectorAll('li'); [].slice.call(aLi).forEach((oLi, index) =&gt; &#123;console.log( oLi, index );&#125;); [...aLi].forEach((oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); Array.from(aLi, (oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原生js获取DOM节点</tag>
      </tags>
  </entry>
</search>
