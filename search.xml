<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2F2018%2F08%2F06%2FBFC%2F</url>
    <content type="text"><![CDATA[BFC 概念BFC：block format context 块级格式化上下文。BFC 规定了该元素及其子元素的行为和 BFC 外部元素之间的关系。 BFC 的创建 overflow：是 auto | hidden 浮动。float 不是 none 定位。position 是 absolute | fixed 弹性盒子。设置 display: flex; BFC 的特性（原理） BFC 内部元素和 BFC 外部元素互不影响。基于这个特性可以解决: 外边距重叠、float 带来的影响等问题。 BFC 整体高度的计算会把浮动的子元素高度，也计算进去。可以实现清除浮动。 BFC 具体事例（解决的问题）1. 两栏布局两栏布局中有一种是：一个盒子浮动，脱离文档流，由于上一个盒子浮动的影响，下一个盒子会占据上一个盒子的空间。不过浮动对块级盒子影响是占据空间形成覆盖，对内联元素/块级元素内的内联元素或者文字的影响则是环绕。 123456789101112131415161718192021222324&lt;style&gt; .left &#123; float: left; width: 100px; height: 100px; background: pink; &#125; .center &#123; height: 120px; background: orange; &#125; .center div &#123; width: 120px; height: 60px; background: green; &#125;&lt;/style&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="center"&gt; &lt;div&gt;hahaha&lt;/div&gt;&lt;/div&gt; 解决方案：此时对浮动后面的盒子创建 BFC，就会消除上一个浮动盒子带来的影响。原理就是 BFC 内部元素和外部元素（这里指的是浮动元素）互不影响。1234567891011121314151617181920212223242526&lt;style&gt;.left &#123; float: left; width: 100px; height: 100px; background: pink;&#125;.center &#123; /* 创建BFC */ overflow: hidden; height: 120px; background: orange;&#125;.center div &#123; width: 120px; height: 60px; background: green;&#125;&lt;/style&gt;&lt;div class="left"&gt;&lt;/div&gt;&lt;div class="center"&gt; &lt;div&gt;hahaha&lt;/div&gt;&lt;/div&gt; 2. 边距合并说起边距合并，有三种。这里只拿出其中一种来举例（其实都可用 BFC 来解决的）。相邻两个块级元素：它们都有外边距，则会发生合并。合并的规则：无负值则取最大值，有负值则边距相加。12345678910111213141516171819&lt;style&gt; div &#123; width: 100px; height: 80px; &#125; .top &#123; margin-bottom: 20px; background: pink; &#125; .bottom &#123; margin-top: 30px; background: orange; &#125;&lt;/style&gt;&lt;div class="top"&gt;&lt;/div&gt;&lt;div class="bottom"&gt;&lt;/div&gt; 解决方案：给一个盒子增加个父元素来创建 BFC，另一个盒子就不会影响 BFC 内部元素了，其实和上一个案例原理一样的。12345678910111213141516171819202122232425&lt;style&gt; div &#123; width: 100px; height: 80px; &#125; .top &#123; margin-bottom: 20px; background: pink; &#125; .bottom-box &#123; display: flex; &#125; .bottom &#123; margin-top: 30px; background: orange; &#125;&lt;/style&gt;&lt;div class="top"&gt;&lt;/div&gt;&lt;div class="bottom-box"&gt; &lt;div class="bottom"&gt;&lt;/div&gt;&lt;/div&gt; 3. 清除浮动浮动带来的影响是很可怕的。可能影响接下来整体布局（常见的坍塌），所以清除浮动很重要。123456789101112131415161718&lt;style&gt; .parent &#123; width: 200px; border: 2px solid red; background: green; &#125; .child &#123; float: left; width: 100px; height: 100px; background: pink; &#125;&lt;/style&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 解决方案：这里介绍清除浮动的方式之一：使用 BFC。给浮动的父元素创建 BFC，那么就能清除浮动。其中的原理就是：当计算父元素的高度时，也会把浮动的元素计算在内。1234567891011121314151617181920&lt;style&gt; .parent &#123; /* 创建 BFC */ overflow: auto; width: 200px; border: 2px solid red; background: green; &#125; .child &#123; float: left; width: 100px; height: 100px; background: pink; &#125;&lt;/style&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 总结：BFC的基本概念、原理、创建方式、解决哪些问题。]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见布局总结2]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%932%2F</url>
    <content type="text"><![CDATA[水平垂直居中定位 + transform思想：父元素相对定位，子元素绝对定位，并且和父元素距离为父元素宽高的一半，再用 transform: translate(-50%, -50%) 让子元素向左、上偏移自已宽高的一半。个人认为：这个方案挺好，灵活性高（省了计算子元素的总的宽高）、兼容 IE9+。 123456789101112131415161718192021&lt;style&gt;.parent &#123; position: relative; width: 200px; height: 220px; border: 1px solid red;&#125;.child &#123; position: absolute; top: 50%; left: 50%; width: 100px; height: 100px; transform: translate(-50%, -50%); border: 1px solid green;&#125;&lt;/style&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt; 定位 + margin: auto思想：父元素相对定位，子元素绝对定位，子元素四角定位为0，再加上 margin: auto。优缺点： 兼容性很好。可兼容到 IE8 代码量有点多 1234567891011121314151617181920212223&lt;style&gt;.parent &#123; position: relative; width: 200px; height: 220px; border: 1px solid red;&#125;.child &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; width: 100px; height: 100px; border: 1px solid green;&#125;&lt;/style&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/&gt;&lt;/div&gt; flex 弹性盒子思想：设置父元素为弹性盒子，并且通过 justify-content: center; align-items: center规定子元素的行为。优缺点： 代码简单，并且如果有多个子元素，可让多个子元素实现这种效果。 兼容性不是很好，兼容 IE10+12345678910111213141516171819&lt;style&gt; .parent &#123; display: flex; width: 200px; height: 220px; justify-content: center; align-items: center; border: 1px solid red; &#125; .child &#123; width: 100px; height: 100px; border: 1px solid green; &#125;&lt;/style&gt;&lt;div class="parent"&gt; &lt;div class="child"&gt;&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常见布局总结1]]></title>
    <url>%2F2018%2F08%2F05%2F%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%931%2F</url>
    <content type="text"><![CDATA[左右宽度固定、中间自适应float思想：左右盒子分别 float，中间的盒子会占据前两个浮动盒子的位置，再给中间盒子左右 margin。优缺点： 兼容性好 浮动的元素脱离文档流，处理不好会影响其他元素。 1234567891011121314151617181920212223&lt;style&gt; #wrap div &#123; min-height: 600px; &#125; .left &#123; float: left; width: 300px; background: pink; &#125; .right &#123; float: right; width: 300px; background: green; &#125; .center &#123; margin: 0 300px; background: skyblue; &#125;&lt;/style&gt;&lt;article id="wrap"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt;&lt;/article&gt; 定位思想：左右盒子定牢固，中间盒子给定left、right，就规定了子元素在父元素的左右间距，也就控制了子元素的宽度。优缺点： 快捷。无论是 css 布局还是 js 操作定位的元素，都是非常快的。 确定和浮动类似。盒子脱离文档流，它的子元素也会脱离文档流。 1234567891011121314151617181920212223242526272829303132&lt;style&gt; #wrap &#123; position: relative; &#125; #wrap div &#123; position: absolute; min-height: 300px; &#125; .left &#123; left: 0; top: 0; width: 300px; background: pink; &#125; .right &#123; top: 0; right: 0; width: 300px; background: green; &#125; .center &#123; left: 300px; right: 300px; background: skyblue; &#125;&lt;/style&gt;&lt;article id="wrap"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/article&gt; flex 弹性盒子思想：给子元素设置为盒子模型，那么其所有子元素在同一行。此时左右两个子元素宽度固定，中间盒子设置 flex: 1 占据父元素所有的剩余空间。我认为 flex 布局是最好的，兼容 IE10+（需要写 -ms-前缀）且快捷、能解决元素脱离文档流的问题。 12345678910111213141516171819202122232425&lt;style&gt; #flex &#123; display: flex; &#125; #flex div &#123; min-height: 300px; &#125; .left &#123; width: 300px; background: pink; &#125; .right &#123; width: 300px; background: green; &#125; .center &#123; flex: 1; background: skyblue; &#125;&lt;/style&gt;&lt;article id="flex"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/article&gt; table-cell 表格布局思想：把父元素设置为 table，规定表格的宽高（宽和屏幕一样宽）。子元素设置为 table-cell，左右两边盒子宽度固定，中间自适应（这点和弹性盒子类似）。优缺点： 兼容性很好 不好操作，对 seo 也不好。一个单元格高度变化，其他单元格高度也一样（牵一发动全身）。 123456789101112131415161718192021222324252627&lt;style&gt; #table &#123; display: table; width: 100%; height: 300px; &#125; #table div &#123; display: table-cell; &#125; .left &#123; width: 300px; background: pink; &#125; .right &#123; width: 300px; background: green; &#125; .center &#123; background: skyblue; &#125;&lt;/style&gt;&lt;article id="table"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/article&gt; Gird 网格布局思想：只要给父元素设置一个网格布局属性即可规定子元素的行为。比如 gird、gird-template-rows、gird-template-columns。优缺点： 代码量很少。 不兼容 IE 1234567891011121314151617181920212223242526&lt;style&gt; #grid &#123; display: grid; /* 像table一样，需要手动设置父元素宽度 */ width: 100%; /* 规定网格布局的高度 */ grid-template-rows: 300px; /* 规定子元素的宽度分布 */ grid-template-columns: 300px auto 300px; &#125; .left &#123; background: pink; &#125; .right &#123; background: green; &#125; .center &#123; background: skyblue; &#125;&lt;/style&gt;&lt;article id="grid"&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="center"&gt;center&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/article&gt; 思考：根据以上经验，也可以对上下高度固定、中间自适应布局，有了解决方案： 定位 弹性盒子 flex 网格布局 grid]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器doctype、渲染原理、性能优化]]></title>
    <url>%2F2018%2F08%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8doctype%E3%80%81%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%E3%80%81%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[有关DOCTYPE的思考DOCTYPE 的分类： html5：&lt;!DOCTYPE html&gt; html4.0.1: 严格模式（strict）、宽松模式（loose）。它们都包含所有的 html 的元素和属性，区别是严格模式并不包含已废弃的元素、属性，宽松模式则包含。 在 html5 中使用 &lt;!DOCTYPE html&gt; 的作用：声明文档的类型为 &lt;!DOCTYPE html&gt;，告知浏览器以浏览器的标准模式来渲染页面。 浏览器的模式： 标准模式：浏览器根据 w3c 标准来渲染页面。 兼容模式/怪异模式/混杂模式：浏览器模仿老师浏览器的行为，并在此基础上兼容新特性。即向后兼容。 浏览器的渲染原理浏览器的渲染过程： 解析 HTML，生成 DOM（如果有外链的 src、href，将会发起请求）。 类似地，也要解析 css，生成 CSSOM（css object model）。 合并 DOM、CSSOM，生成一颗 render tree–渲染树。 布局。通过计算各个元素的尺寸和位置，布局渲染树。 将布局绘制在屏幕上。 重排（reflow）：概念：每个 DOM 元素都有自己的盒子（模型），浏览器根据样式计算元素的位置、尺寸将元素放到相应的位置。触发重排的因素： 修改 DOM 的结构。 修改元素的样式（位置、宽高、display: none 这种样式）。 用户事件（比如鼠标悬停、页面滚动、输入框键入文字、改变窗口大小等等） 重绘（repaint）：概念：将位置、宽高、颜色等样式确定下后，浏览器将元素显示在页面上的过程。触发 repaint 的因素： 一般重排过后就会发生重绘。 当修改元素背景色、字体颜色等样式时，会触发重绘（此时不会触发重排）。 减少重排、重绘： 尽量使用离线DOM。使用DocumentFragment将需要多次修改的DOM元素缓存，操作完成后最后一次性append到真实DOM节点中渲染；使用cloneNode()方法，在克隆节点上进行操作，然后用克隆的节点替换原始节点。 逐个修改节点样式尽量一次性修改。eg: 动态地该节点增添class、cssText。 可以需要多次修改的DOM元素设置为display: none；操作完在显示。（因为隐藏元素不在render树内，修改隐藏元素不会触发回流、重绘。这样仅需要两次回流、重绘）。 避免读取某些有关元素位置、宽高等属性：offsetLeft、offsetTop、offsetWidth、offsetHeight、scollTop/Left/Width/Height、clientTop/Left/Width/Height、调用getComputedStyle()或者ie的currentStyle。 使用类似 Vue、React的虚拟节点。 js运行机制对 js 单线程的理解：js 单线程：js 只有一个主线程，在同一时间只能做一件事情。为啥不能通过多线程来提高效率呢？因为如果多线程之间存在互斥行为就很尴尬了。比如有两个线程在运行 js 代码，一个修改某个 DOM 节点的内容，另一个却删除了该节点，em….. 任务队列：分为同步任务和异步任务。同步任务是指在主线程上安排的任务，只有前面的任务执行完，才能轮到下一个任务。 异步任务是指不进入主进程的被暂时挂起的任务，被加入到任务队列中。只有任务队列通知主线程某个异步任务可以执行了（主线程有空闲），那么该异步任务才会进入主线程执行。 事件循环： 运行主线程的同步代码，此时会产生堆栈（执行栈）。 主线程异步操作，先会放到 event table 中，当异步操作准备好（和 web-API 相关）时，就会进行异步的任务队列中等待主线程的调用。 当主线程上的同步代码执行完毕，会把异步任务队列的任务放到主线程上执行（这里：微任务优先级大于宏任务）。 执行任务时会产生新的异步操作，就会产生新的循环。 微任务（jobs）：process.nextTick、promise宏任务（task）：script、setTimeout、setInterval等。 相关链接：js 运行机制1、js 运行机制2、阮老师-js运行机制 页面性能优化 资源合并压缩，减少 http 请求。 非核心代码异步加载。 浏览器缓存 使用 CDN DNS 预解析。 资源合并压缩，减少http请求：压缩静态资源文件，包括 html、js、css，其中 css 用来主要是删除其中未使用的样式。后台开启 gzip 压缩，雪碧图或者base64 转换。 非核心代码异步加载： 动态脚本加载 12345var script = document.createElement('script');script.type = 'text/javascript';script.src = 'http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js';script.async = true;document.getElementsByTagName('head')[0].appendChild(script); 延迟执行 deferdefer 脚本下载后不能立即执行，需要在 html 解析后执行。如果多个 defer ,则按照书写顺序依次执行。 1&lt;script src="//www.google-analytics.com/analytics.js" defer&gt;&lt;/script&gt; 异步执行 asyncasync 是在 js 下载完成后立即执行，会和 html 解析并行执行。如果是多个，执行顺序和加载顺序无关。 浏览器缓存缓存：浏览器把资源文件备份到用户本地，当用户再次打开网站时，可使用缓存文件，不同再通过链接来请求。这样可加速打开页面。 浏览器缓存原理： 浏览器在请求某个资源时，先获取该资源缓存的 header 信息，通过 Expires、Cache-control 头信息判断之前是否采用强缓存，如果采用了强缓存，则直接使用本地的缓存文件，不再和服务器通信。 如果未采用强缓存或者强缓存失效了，浏览器就会向服务器发送请求，请求会携带第一次请求服务器返回有关缓存的 header 信息（If-Modified-Since（和 Last-Modefied配合使用 ）、If-None-Match（和 Etag配合使用）），然后服务器根据请求有关的 header 信息来判断之前是否进行了协商缓存，如果是协商缓存，则会返回新的 header 缓存信息来更新之前有关缓存的 header 信息，但并不会返回资源文件，而是告知浏览器从缓存中获取；否则，返回资源文件。注意：Last-Modefied、Etag 是响应头的字段，If-Modified-Since、If-None-Match是请求头中的字段，这个字段的值就是前两者的值。 缓存分类 强缓存：不用和服务端通信，执行从缓存中拿到资源。状态码：200 (from memory cache)。在请求 header 字段中，包含 Expires、Cache-control信息。注意：如果两个字段同时存在的话，Cache-control 优先级会高于 Expires。 协商缓存：需要和服务端通信，通过服务器告知之前的缓存是否可用。状态码：304 (not modified)。 一个问题浏览器将某个资源文件强缓存在本地，如果服务器端更新了该文件，但是此文件在浏览器端还在缓存期内，那么浏览器会一直从本地调用老资源，不会获取服务器的最新资源。此时的解决办法是：通过数据摘要算法给文件增加类似 hash 值的东西，这个摘要信息和文件会一一对应，一旦文件内容改变，该摘要也会改变。从而让浏览器主动放弃缓存，加载新资源。并且这种给每个文件添加摘要的方式，可以实时监控每个文件的变动，然后对每个发生变化的文件重新获取资源。12&lt;link ref="stylesheet" src="demo.css?v=0e5fhd"/&gt;.... 学习链接：性能优化/http之强缓存和协商缓存、张云龙之缓存 网络性能优化—使用CDNCDN：内容分发网络。尤其第一次加载页面时，浏览器缓存没效果，此时使用 CDN 加速，效果明显。使用 CDN 加速原理：把 js、css、视频等静态文件通过 CDN 分发到全国乃至全世界的各个节点，用户就可以从距离最近的边缘节点拿到所需的资源文件，从而提升内容下载速度，以达到快速打开网页的目的。 预解析 DNS使用方式：在 html 文件的 head 标签内部使用以下代码：1&lt;link rel="dns-prefetch" href="//static.mocrosoft.com"/&gt; 另外：页面中的 a 标签默认是打开了 dns 预解析的。但是使用了 https 协议时，在一些浏览器中 a 标签不会进行 dns 预解析，此时需要使用以下代码：1&lt;meta http-equiv="x-dns-prefetch-control" content="on"/&gt;]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DOM事件深入浅出]]></title>
    <url>%2F2018%2F08%2F01%2FDOM%E4%BA%8B%E4%BB%B6%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%2F</url>
    <content type="text"><![CDATA[DOM 事件级别 DOM0：将一个函数赋值给 DOM 节点的事件处理属性。缺点：对于 DOM 节点的同一种事件处理，不能给它绑定多个函数。否则，后者会覆盖前者。12345var oBox = document.querySelector('div');oBox.onclick = function () &#123; console.log('hahaha!');&#125;; DOM2：使用 addEventListener | attachEvent 形式给 DOM 节点注册事件。注意：主流浏览器用 addEventListener/removeEventListener，IE8-使用 attachEvent/detachEvent注册/注销事件，它们在传参上略有差别。 主流浏览器有事件捕获，IE8- 没有，只有事件冒泡，也就是说使用 attachEvent/detachEvent 不需要传第三个参数； 在事件注册/捕获中，主流浏览器不需要加 on、IE8- 则需要加上。 事件触发函数的 this 指向不同。主流浏览器指向注册/销毁事件的对象，IE8- 指向 widnow。123456789// 事件注册的兼容写法function getEvent (obj, event, fn) &#123; document.addEventListener ? obj.addEventListener(event, fn) : obj.attachEvent('on' + event, function () &#123; fn.call(obj); &#125;);&#125;getEvent(oBox, 'click', function (e) &#123; console.log(e, this); &#125;);// 这种写法弊端：在ie8-无法注销了。 因为匿名函数内存地址不同了！ DOM3：在 DOM2 事件级别上多添加了几种事件，还可以自定义事件。 UI事件，当用户与页面上的元素交互时触发，如：load、scroll 焦点事件，当元素获得或失去焦点时触发，如：blur、focus 鼠标事件，当用户通过鼠标在页面执行操作时触发如：dbclick、mouseup 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：mousewheel 键盘事件，当用户通过键盘在页面上执行操作时触发，如：keydown、keypress 注意：是存在 DOM1 标准的，但是没有 DOM1 事件标准，因为在 DOM 标准中并没有定义与事件相关的内容。 事件模型捕获和冒泡 事件流事件流分三个阶段： 捕获。事件自上而下地从 window 转递到事件源的过程。使用 addEventListener 第三个参数默认是false，也就是不进行事件捕获。 目标阶段。捕获到了事件源的过程。 冒泡：事件自底向上从事件源传递到 window 的过程。 事件捕获得具体流程： Event 对象得常见使用 e = e || window.event：兼容 IE 的 event 对象。 去除默认事件。通常是 e.preventDefault() ，在 IE8- 的兼容是： 1234document.onclick = function (e) &#123; e = e || window.event; -[1,] ? e.preventDefault() : e.returnValue = false; // -[1,] -1 NaN&#125;; 去除冒泡。通过 e.stopPropagation() 或者 e.cancelBubble = true 来阻止事件冒泡。 e.stopImmediatePropagation() 是用来去除冒泡。如果一个 DOM 通过 addEventListener 这种形式绑定多个事件执行函数，并且在某次函数中设置了 e.stopImmediatePropagation() ，将不会执行以后的事件处理函数。IE9+ （官方解释：如果有多个相同类型事件的事件监听函数绑定到同一个元素,则当该类型的事件触发时,它们会按照被添加的顺序执行。如果其中某个监听函数执行了 event.stopImmediatePropagation() 方法，则剩下的监听函数将不会被执行。） 1234567891011121314151617181920212223242526/*&lt;div&gt; &lt;p&gt;paragraph&lt;/p&gt;&lt;/div&gt;*/document.querySelector("p").addEventListener("click", function(event)&#123; alert("我是p元素上被绑定的第一个监听函数");&#125;, false);document.querySelector("p").addEventListener("click", function(event)&#123; alert("我是p元素上被绑定的第二个监听函数"); event.stopImmediatePropagation(); //执行stopImmediatePropagation方法,阻止click事件冒泡,并且阻止p元素上绑定的其他click事件的事件监听函数的执行.&#125;, false);document.querySelector("p").addEventListener("click", function(event)&#123; alert("我是p元素上被绑定的第三个监听函数"); //该监听函数排在上个函数后面,该函数不会被执行.&#125;, false);document.querySelector("div").addEventListener("click", function(event)&#123; alert("我是div元素,我是p元素的上层元素"); //p元素的click事件没有向上冒泡,该函数不会被执行.&#125;, false); e.target 找到事件源。通常和事件代理有关。比如多个 li，它们同时把 click 事件委托给父元素，那么就可以通过 e.target 获得事件源（谁触发了该事件）。IE8-用 srcElement。 e.clientX、e.clientY：相对可视区的鼠标位置。 e.pageX、e.pageY：相对文档的鼠标位置。 自定义事件（模拟事件）IE 并不支持自定义事件。12345678// 创建事件 如果想向事件对象e中传递数据，可以使用CustomEvent对象var myEvent = new Event('build');// 给DOM元素注册事件elem.addEventListener('build', function (e) &#123;&#125;, false);// 触发该事件elem.dispatchEvent(myEvent); 一个小demo:12345678910111213141516/*&lt;div&gt;haha&lt;/div&gt;&lt;p&gt;lala&lt;/p&gt;*/// 当点击p元素时，触发div元素上的事件build，并打印事件对象。var event = new CustomEvent('build', &#123;'detail': 1&#125;), elem = document.querySelector('div');elem.addEventListener('build', function (e) &#123; console.log(e);&#125;, false);document.querySelector('p').addEventListener('click', function () &#123; elem.dispatchEvent(event);&#125;);]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[同源策略、ajax]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E3%80%81ajax%2F</url>
    <content type="text"><![CDATA[同源策略同源策略是指：正常情况下，一个源的文档和脚本不能与另一个源的资源进行交互。它是浏览器一种自我保护的安全机制。源：协议、域名、端口必须相同。同源策略限制一下方面： 无法获取 Cookie、LocalStorage 、IndexDB 无法获得 DOM 不能发送 AJAX 请求 前后端如何通信 AJAX：受到同源策略的影响 Webscoket、CORS：不受同源策略的影响 如何创建 ajax需要注意一下几点： XMLHttpRequest 对象的工作流程 兼容性的处理 事件的触发条件 事件的触发顺序 12345678910111213141516171819202122232425262728293031323334353637function ajax (options) &#123; var url = options.url, type = options.type ? options.type.toUpperCase() : 'GET', data = options.data, success = options.success, error = options.error, dataStr = data &amp;&amp; function () &#123; var dataArr = [], k; for(k in data) dataArr.push(k + '=' + data[k]); return dataArr.join('&amp;'); &#125;(); // 创建 ajax 对象，考虑兼容性 var xhr = XMLHttpRequest ? new XMLHttpRequest : new window.ActiveXObject('Microsoft.XMLHttp'); if (type === 'GET') &#123; url = url + '?' + (dataStr || '') + '&amp;_=' + Date.now(); // IE 低版本缓存问题 xhr.open('GET', url, true); xhr.send(null); &#125; if (type === 'POST') &#123; xhr.open('POST', url, true); xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded'); xhr.send(dataStr); &#125; xhr.onreadystatechange = function () &#123; if(this.readyState === 4) &#123; var status = this.status; if(status &gt;= 200 &amp;&amp; status &lt;= 400) &#123; success &amp;&amp; success instanceof Function &amp;&amp; success(this.response); &#125;else &#123; error &amp;&amp; error instanceof Function &amp;&amp; error(status); &#125; &#125; &#125;;&#125; 跨域通信的方式 jsonp利用 script 标签无跨域限制、可异步加载的特性。具体做法：动态创建一个 script 标签，可以给服务器传参并指定回调函数的名称 callback=cb，服务器接到请求后，将数据放到这个返回函数中发送给客户端。jsonp 缺点就是只能执行 GET 请求。 1234567891011121314151617181920212223242526272829function createScript (options) &#123; var url = options.url, data = options.data, callbackName = options.callbackName, dataStr = data &amp;&amp; function () &#123; var dataArr = [], k; for(k in data) dataArr.push(k + '=' + data[k]); return dataArr.join('&amp;'); &#125;(); var script = document.createElement('script'); script.setAttribute('type', 'text/javascript'); script.async = true; script.src = src + '?' + (dataStr || '') + '&amp;cb=' + callbackName; document.getElementsByTagName('head')[0].appendChild(script);&#125;function getInfo (data) &#123; console.log (data);&#125;// 例如百度搜索createScript(&#123; src: 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su', data: &#123; wd: '啦啦啦' &#125;, callbackName: 'getInfo'&#125;) hash利用 url 中 hash 的改动页面并不刷新，而 search 会刷新。使用场景：在窗口 A 中通过 frame 嵌入窗口 B，这两个窗口可用 hash 来通信。 12345678// 在 A 窗口中B = document.querySelector('iframe');B.src += '#' + 'data';// 在 B 窗口中 子窗口接受父窗口传参，反之也可以window.onhashchange = function () &#123; var data = this.localtion.hash;&#125;; postMessagehtml5 新增的跨域 API，可实现跨域通信。使用场景：在窗口 http://a.com 中通过 frame 嵌入窗口 http://b.com，这两个窗口可用 postMessage 来通信。 12345678910// 在 A 窗口中BWindow = postMessage('http://b.com', 'data');// 在 B 窗口中window.addEventListener('message', handleMsg);function handleMsg (e) &#123; console.log(e.origin, e.source, e.data) // http://a.com BWindow data // 发送消息的窗口 消息发向的网址 消息内容 可使用e.origin来过滤指定网站发送过来的数据&#125; WebScokethttp 只能单向通讯，且不是实时性的。 webscoket 就解决这两个弊端。它提供一种及时的双向通信服务，客户端可实时地从服务端获取数据，服务端也可向客户端发送数据。 1234567891011121314151617// 创建 ws 对象var ws = new WebScoket('wss://www.example.com/server.php');// 监听三类事件ws.onopen = function () &#123; console.log('Connection start!'); ws.send('hi, server!') // 使用 WebScoket 成功和服务端建立链接，并发送消息&#125;;ws.onmessage = function (e) &#123; console.log(e.data) // 在连接中，客户端接受来自服务端的消息时触发 ws.close() // 在某一次一言不合中关闭了连接，触发close函数&#125;;ws.onclose = function () &#123; console.log('Connection stop!');&#125; CORS在进行 ajax 请求时，浏览器会自动在头部信息里增加一个 Origin 字段，用来表示请求来自与哪个源，服务器根据这个值决定是否同意此次请求。如果 Origin 不在请求范围内，服务器返回一个正常的 http 回应。这个回应的头信息中没有 Access-Control-Allow-Origin字段，浏览器发现没有这个字段之后就会抛出一个错误。如果Origin在请求范围内，服务器返回的响应会多出几个以 Access-Control- 为开头头信息字段。重要: 阮一峰老师：《跨域资源共享 CORS 详解》 以下是掘金网站某次 CPORS 请求的 Request、Response头部信息：]]></content>
      <categories>
        <category>通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对http的了解]]></title>
    <url>%2F2018%2F07%2F28%2F%E5%AF%B9http%E7%9A%84%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[http协议的主要特点 简单快速：浏览器向服务器请求某个资源时，只需传送请求方法和请求地址即可。 灵活：通过 http 协议可以传输不同类型的数据。数据类型可有 Content-type、Accept-type来标记。 无连接：每次连接只处理一次请求。服务器处理完客户的请求并收到浏览器的应答后，即断开连接，这种方式节省了连接时间。 无状态：http 协议是无状态协议，不会对事务的处理有记忆能力，不能区分连接者的身份。 http协议的报文组成部分请求 request： 请求行：包括请求方式、请求地址、采用 http 及版本 请求头：包括许许多多的键值对儿，也可以说是报文头属性及其值。通常报文头包含的属性有： Accept：告诉服务端我客户端能够接受的数据类型。 Cookie：传送给服务端 cookie 信息。 Refer：表示从哪个 url 发过来的请求。比如使用谷歌搜索掘金网站，查看 Refer 就是 https:www.google.com...。 Cache-Control：对缓存进行控制。如将一个请求过来的结果在客户端上要被缓存7天或者不缓存(no-cache)等。… 空行：\r \n 这些转义字符。目的告知服务器空行上部才是请求头，下部是请求体了，分别解析。 请求体：浏览器向服务器发送的请求参数。 响应 response: 响应头：采用 http 及版本、http 响应码和状态描述 响应头：也是和请求头一样由多个属性组成。 空行：\r \n 这些转义字符。 响应体：服务器向浏览器响应的资源。我们客户端需要的“宝贝”。 http请求方法 GET: 获取资源 POST: 传输资源 PUT：更新资源 DELETE：删除资源 HRAD: 获得报文首部 主要使用 GET、POST 两种请求方式。 GET、POST的区别 GET 参数显示在 url 中，POST 参数放在 request body 中。 在 url 中，GET 的请求参数长度有限制的，超出长度会被截断，大概2kb， POST 请求没有限制。 GET 请求会被浏览器主动缓存， POST 请求则不会，除非手动设置。 GET请求的 url 可以被收藏， POST 请求则不可以。 GET请求只发送一个 TCP 数据包，而 POST 请求会发送两个数据包。对于GET方式的请求，浏览器会把 http header 和data 一并发送出去，服务器响应200（返回数据）； 而对于 POST，浏览器先发送 header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 http 状态吗 1xx 消息，一般是告诉客户端，请求已经收到了，正在处理，别急… 2xx 处理成功，一般表示：请求收悉、我明白你要的、请求已受理、已经处理完成等信息. 3xx 重定向到其它地方。它让客户端再发起一个请求以完成整个处理。 4xx 处理发生错误，责任在客户端，如客户端的请求一个不存在的资源，客户端未被授权，禁止访问等。 5xx 处理发生错误，责任在服务端，如服务端抛出异常，路由出错，HTTP版本不支持等。 常见的状态码： 200 OK 请求成功 客户端最容易看到的状态码。 206 Partical Content 客户端发送一个带有 range 头的 get 请求，服务端处理了它。 一般用于 video、audio 的加载。 303 See Other url重定向，目标url放在响应头的 location 字段中。 304 Not Modified 告诉客户端可从浏览器缓存中读取资源。 403 Forbidden 无访问权限 404 Not Found 找不到目标url，请求不到资源。 500 Interval Server Error 服务器出现未知错误，后端需要查看服务端日志。而前端只能通过缓存中得到数据。 持续连接和非持续连接非持续连接：即采用非 keep-alive 模式，每次客户端请求都要和服务器建立连接，服务端返回响应结果后断开连接（证明 http 协议是无连接协议）。持续连接：1.1版本才支持的持久连接。采用 keep-alive 模式，这种模式使得客户端和服务端得连接持续有效，避免了非持续连接每次重新建立连接得延时。 管线化管线化的原理：在持久连接的前提下，将多个 http 请求整批提交到服务器，服务器也类似地把多个响应结果打包发送到客户端。 管线化的特点： 必须在持久连接下完成，仅 http1.1 版本支持持久连接。 只有 GET、HEAD 请求方式可以进行管线化，而 POST 请求有所限制。 初次创建连接时不应该启动管线化机制，因为服务器并不一定支持 http1.1 版本的协议。]]></content>
      <categories>
        <category>通信</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css 盒模型]]></title>
    <url>%2F2018%2F07%2F27%2Fcss-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[概念css 盒模型分为两类：标准盒模型（w3c盒模型）、怪异盒模型（IE盒模型）。 同：他们都有盒模型该有的基本属性 margin、border、padding、width、height等。异：计算宽高的方式不同。标准盒模型的宽高就是 content 的宽高；怪异盒模型的宽高不仅仅包含着 content 的宽高，还包含着 padding、border。 设置这两种盒模型通过 css3 新增属性 box-sizing 即可规定一个元素的盒模型。IE8+box-sizing: content-box 元素默认的盒模型。box-sizing: border-box 设置元素的盒模型是怪异盒模型。 获取盒模型的宽高 dom.style.width(height) 获取 dom 节点的内联样式的宽高。 (dom.currentStyle || window.getComputedStyle(dom)).width(height) 获取 dom 节点的宽高，不分元素样式的添加方式，前者兼容 ie、后者兼容主流浏览器。 dom.getBoundingClientRect() 获取包含着当前 dom 节点的位置（left、top、right、bottom）和宽高（width、height）的键值对儿。 注意：如果当前节点包含 padding、border，它获取的是总宽高。 IE9+ dom.clientWidth(height) 获取包含着 padding 的元素宽高。如果没 padding，就是内容宽高。 dom.offsetWidth(height) 获取包含着 padding 、border 的元素宽高。如果没 border，和上函数一样，也没 border 就是内容宽高。 实际使用情况对于一个给定的盒子，当你给它增加 padding、border 时候，却不想增加它的总宽高，就可以设置为怪异盒模型。在移动端用的居多。]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Math对象]]></title>
    <url>%2F2018%2F07%2F18%2FMath%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[MathMath 对象是 js 提供的内置对象，挂载在 Math 对象的方法有时真的很有用。 几个常用 API Math.maxMath.max.apply(null, [1,2,10,2]) 求的数组中最大值 Math,minMath.min.apply(null, [1,2,10,2]) 类似地，求的数组中最小值 Math.floorMath.floor 向下取整（俗称地板函数） 注：parseInt、num | 0、num &gt;&gt; 0、~~num 也可向下取整num，和 Math.floor不同的是： Math.floor 是真正的向下取整，而其他则是直接去除 interval(小数) 的小数部分（因为0在内存中没有小数部分）； 对于 NaN、infinity 特殊数字向下取整的结果并不同； 12345let arr = [1.6, -2.2, .1, NaN, Infinity, '-1.7', '1.1']arr.forEach(v =&gt; &#123; console.log(Math.floor(v), v | 0, ~~v, v &gt;&gt; 0, parseInt(v))&#125;) Math.random 产生随机数（包含小数）。默认0-1；随机 [2, 5) Marh.random() * 3 + 2； Math.ceil 向上取整（俗称天花板函数） Math.abs 取绝对值 Math.sqrt 开平方 其他Math对象的API -&gt; w3c]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单页应用和多页应用]]></title>
    <url>%2F2018%2F07%2F06%2F%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%92%8C%E5%A4%9A%E9%A1%B5%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[单页应用 SPA单页应用：每次页面跳转不需要请求会 html 文件，它是通过 js 清除当前页面内容、重新挂载新的页面形成的。是局部刷新特点： 不需要请求新的 html 文件和重复的资源文件，减少 http 请求次数、降低请求延时，带来页面间切换快的特点。 缺点： 首屏展示慢。需要请求 html、js 文件，当这些文件全部请求到时，才会展示页面。 seo 效果不好。因为单页面应用是靠 js 动态渲染产生的，而搜索引擎是不识别 js 文件的。 解决以上单页面缺点的方式：服务器端渲染。 多页应用 MPA多页应用：每次页面跳转 web后台都会返回新的 html 文件。是整页刷新。特点： 首页加载时间短。因为页面的跳转只需要向服务器请求一个 html 文件，拿来展示就行。 有利于 seo 优化。因为搜索引擎可识别 html 文件内容，根据内容的权重对网页进行排名。 缺点： 页面间切换慢。因为页面的跳转会加载与之页面相关的全部资源 js、img等，如果网络不流畅，就会出现页面卡断、白屏情况。]]></content>
      <categories>
        <category>前端之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue-bus总线]]></title>
    <url>%2F2018%2F07%2F05%2Fvue-bus%E6%80%BB%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Vue 非父子组件通讯 频繁使用的 $emit、props 来传递，显得代码冗余、繁琐。 vuex：vue生态中的一个插件，用来保存组件间的共享数据，实现组件间的通讯。 bus 总线：当项目并不大使用 vuex 就是杀鸡用牛刀，可用 bus 总线技术实现组件通讯。 bus 总线为了解决非父子组件之间的关系，可以考虑从 bus 总线技术。其原理是：在 vue 的原型对象上挂载一个属性 bus（或者单独做一个 bus.vue 中央处理组件），这个属性是一个 vue 对象，这个对象就是非父子组件通讯的桥梁。当我们组件通讯时，使用 this.bus 找到该桥梁。即可利用 vue 对象内部方法 $emit 触发事件、$on 监听组件触发的事件并接受信息从而实现通讯。 bus 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/*HTML&lt;!-- 兄弟组件信息的互相传递 --&gt;&lt;div id="wrap"&gt; &lt;left&gt;&lt;/left&gt; &lt;right&gt;&lt;/right&gt;&lt;/div&gt;*/Vue.prototype.bus = new Vue();Vue.component('left', &#123; template: `&lt;div&gt; &lt;h3 @click="giveMsg"&gt; &#123;&#123;msg&#125;&#125; &lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是左边的组件' &#125; &#125;, methods: &#123; giveMsg() &#123; this.bus.$emit('giveMsgToRight', this.msg); &#125; &#125;, created() &#123; this.bus.$on('giveMsgToLeft', msg =&gt; &#123; console.log(msg); &#125;); &#125;, beforeDestory() &#123; // 最好在组件销毁前，清除事件监听 this.bus.$off('giveMsgToRight'); &#125;&#125;);Vue.component('right', &#123; template: `&lt;div&gt; &lt;h3 @click="giveMsg"&gt; &#123;&#123;msg&#125;&#125; &lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是右边的组件' &#125; &#125;, methods: &#123; giveMsg() &#123; this.bus.$emit('giveMsgToLeft', this.msg); &#125; &#125;, created() &#123; this.bus.$on('giveMsgToRight', msg =&gt; &#123; console.log(msg); &#125;); &#125;, beforeDestory() &#123; this.bus.$off('giveMsgToRight'); &#125;&#125;);const vm = new Vue(&#123; el: '#wrap'&#125;); bus 总线总结 可把这个 “桥梁” 单独拿出来作为一个 vue 组件，谁用谁导入。 组件销毁之前，需要去除 bus 上的事件监听。 稍微复杂点的项目，只能乖乖使用 vuex 进行更复杂的状态管理了。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue中的事件绑定]]></title>
    <url>%2F2018%2F07%2F04%2FVue-%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[事件绑定分类Vue 中使用 v-on/@ 来绑定事件，大致划分三类事件： 给普通 dom 元素绑定原生事件； 给组件绑定原生事件； 给组件绑定自定义事件； 给普通 dom 元素绑定原生事件通过触发普通 dom 元素的原生事件，执行相关的 dom 操作。1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3 @click="fn"&gt; 这是子组件 &lt;/h3&gt; &lt;/div&gt;`, methods: &#123; fn(e) &#123; e.target.innerText = '是的，我是子组件！' &#125; /* 不传参，形参e指代事件对象（当然，不用时可省区）； 传参并且函数内部需要使用时间对象e，则需要在实参中传入$event */ &#125;&#125;);const vm = new Vue(&#123; el: '#wrap'&#125;); 给组件绑定原生事件给组件绑定原生事件，通过 .native 事件修饰符，来触发父组件内部函数。123456789101112131415161718192021222324252627/*HTML &lt;div id="wrap"&gt; &lt;my-component @click.native="fn"&gt;&lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3&gt; 这是子组件 &lt;/h3&gt; &lt;/div&gt;`&#125;);const vm = new Vue(&#123; el: '#wrap', methods: &#123; fn() &#123; alert('给组件绑定原生事件测试!') &#125; /* 不传参，形参e指代事件对象（当然，不用时可省区）； 传参并且函数内部需要使用时间对象e，则需要在实参中传入$event */ &#125;&#125;); 给组件绑定自定义事件给组件绑定自定义事件，就是我们非常熟悉的子组件通过触发事件向父组件传值情形啦。1234567891011121314151617181920212223242526272829303132/*HTML&lt;div id="wrap"&gt; &lt;my-component @change="fn"&gt;&lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3 @click="giveMsgToParent"&gt; 这是子组件 &lt;/h3&gt; &lt;/div&gt;`, methods: &#123; giveMsgToParent() &#123; this.$emit('change', 'hahaa, 我是子组件，我来传值了！') &#125; &#125;&#125;);const vm = new Vue(&#123; el: '#wrap', methods: &#123; fn(msg) &#123; console.log('子组件传递过来的值是： ' + msg); &#125; /* 不传参，形参e指代事件对象（当然，不用时可省区）； 传参并且函数内部需要使用时间对象e，则需要在实参中传入$event */ &#125;&#125;);]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue中 prop特性和非prop特性]]></title>
    <url>%2F2018%2F07%2F04%2Fvue-prop%E7%89%B9%E6%80%A7%E5%92%8C%E9%9D%9Eprop%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[prop 特性prop 特性：父组件通过绑定属性形式来给子组件传值，子组件通过 props 声明传入值的键并对键值校验，校验成功后该值即可使用在子组件模板中。 1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;my-component :content="msgToComponent"&gt;&lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3&gt; 传递过来的数据是--- &#123;&#123; content &#125;&#125; &lt;/h3&gt; &lt;/div&gt;`, props: &#123; content: &#123; type: String, required: true &#125; &#125;&#125;);const vm = new Vue(&#123; el: '#wrap', data: &#123; msgToComponent: '这是从父组件传递过来的数据' &#125;&#125;); 非 prop 特性非 prop 特性：父组件也可以通过属性的绑定传值过来，但子组件并不用 props 选项来声明接受传值，当然更不可直接用在模板中，否则出现错误。那么通过非 prop 传递过来的值只有一个用处：给子组件模板最外层的包裹元素添加个属性。1234567891011121314151617181920/*HTML&lt;div id="wrap"&gt; &lt;my-component :content="msgToComponent"&gt;&lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3&gt; 这是子组件 &lt;/h3&gt; &lt;/div&gt;`&#125;);const vm = new Vue(&#123; el: 'div', data: &#123; msgToComponent: '这是从父组件传递过来的数据' &#125;&#125;); prop 特性和非 prop 特性的总结 prop 特性则是：父组件传、子组件接并将其使用在模板中。非 prop 特性则是：父组件传、子组件不接且不能再子组件内部使用传值，而是直接显示在子组件最外层的包裹元素中。 在实际生产环境中，非 prop 特性使用场景不多，而 prop 特性的使用才是主流！]]></content>
  </entry>
  <entry>
    <title><![CDATA[我对前端工程化、模块化、组件化的理解]]></title>
    <url>%2F2018%2F07%2F03%2F%E6%88%91%E5%AF%B9%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前端工程化node.js 未出现之前，前后端并未实现分离，所谓的前端就是简单页面制作，会 html 完成网页结构，css 修饰网页， jquery 完成网页 dom 操作、实现与用户交互即可，或者说前端仅仅是后端一个附属品。但是随着 node.js 之后，前端越来越受重视，所占软件开发的比重愈来愈高，前端规模越来越大，这将会引出工程学的概念，前端工程化根据业务特点，将前端开发流程（要素）分为：需求分析、技术选型、代码规范、组件管理、真机测试、自动化构建、部署上线。按照这种开发流程的（前端工程化的）目的就是提供前端开发效率和质量。 模块化我认为模块最重要的就是：能够重用、分而治之。每一个模块都有自己高度封装的逻辑代码，并且它们每一个模块并不会和其他模块有很强的代码粘连性。例如：在模块 A 中使用模块 B 仅需引入模块 B，使用模块B暴露出的接口、函数、对象就行。这种模块内部高度封装，各模块之间关联性不强的前端模块化操作也符合“高内聚、低耦合”的模块设计构想。涉及前端模块化的点有：es6、Common.js、AMD、CMD 、less、sass等。 组件化组件化是基于模块化的，模块化是对同一种东西的封装，而组件化则在模块化的基础上添加了其他元素。比如 node.js 中单个 .js 文件是个模块，在 vue.js 中，.vue 文件是个组件了，因为其内部多了除 js 以外其他东西。除了模块重用、分而治之的特点外，组件还有组合性的特点。把一个页面分为多个分区，亦可看多个组件，组合这么多的组件也就完成当前页面。 学习链接： 前端组件化 深入探讨前端组件化开发 浅说前端工程化]]></content>
      <categories>
        <category>前端之路</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web安全]]></title>
    <url>%2F2018%2F07%2F02%2FWeb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[XSSxss：cross site scripting 跨站脚本攻击。攻击原理：攻击者向网页恶意植入 html 标签或者 js 脚本。比如：植入了表单提交 html 代码，当用户提交时，目标服务器是攻击者的服务器，而不是用户原以为的信任站点；植入的 js 脚本，js 可获得用户的 cookie 信息。 防范方法： 编码：对用户上传的内容通过网页实体来编码。 过滤：移除用户上传的 dom 属性，如 onerrpr、onclick等；过滤掉 style、script、iframe 标签等。 CSRFCSRF：Cross Site Request Forgery 跨站请求伪造攻击原理：伪装成站点用户进行攻击。攻击者通过盗用用户的身份信息，并以用户的名义发送恶意请求。 防范方法： Referer 验证。 HTTP Referer 字段。在 HTTP 头中有 Referer 字段记录该 HTTP 请求的来源地址，如果跳转的网站与来源地址相符，那就是合法的，如果不符则可能是 csrf 攻击，拒绝该请求。因为通常来说，Referer 字段应和请求的地址位于同一域名下。 Token 验证。在 http 请求头中加入 token。 这种的话在请求的时候加一个 token，值可以是随机产生的一段数字，token 是存入数据库之后，后台返给客户端的，如果客户端再次登录的时候，后台发现 token 没有，或者通过查询数据库不正确，那么就拒绝该请求。 如果想防止一个账号避免在不同的机器上登录，那么我们就可以通过 token 来判断，如果a机器登录后，我们就将用户的 token 从数据库清除，从新生成，那么另外一台b机器在执行操作的时候，token 就失效了，只能重新登录，这样就可以防止两台机器登同一账号。 XSS和CSRF的区别：XSS 是用户向你的网站注入 js 脚本，运行其中的函数、代码等。CSRF 是利用网站漏洞来执行一些接口，并且是基于用户登陆的。]]></content>
      <categories>
        <category>Web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typescript声明变量及解构]]></title>
    <url>%2F2018%2F06%2F30%2Ftypescript%E5%A3%B0%E6%98%8E%E5%8F%98%E9%87%8F%E5%8F%8A%E8%A7%A3%E6%9E%84%2F</url>
    <content type="text"><![CDATA[typescript 变量声明typescript 也可用 var、let、const 声明变量，但是更推荐 es6 所提倡 let、const 声明变量。const 声明是对 let 进一步的约束，变量值不能更改。 同 es6 类似地：使用 let、const 声明的变量有一下便利： 让变量使用更加规范 变量不能重复定义； 变量不能生命前使用，会造成短暂性死区； 变量所处的 {} 内存在块级作用域，不需要再像 es5 一样使用闭包来保存变量； 变量只在自己块作用下有效； const 与 let 声明的变量唯一不同是：使用 const 声明的变量不能更改变量值，其他语法一样； 变量不声明不允许使用这种机制可解决使用 var 带来变量提升的弊端； 12345678910111213141516171819202122232425262728293031323334// 变量不能重复定义let str = '123';let str = '456'; // Errorlet str1 = '123';var str1 = '456'; // Errorvar str2 = '123';var str2 = '456'; // 没什么卵用，覆盖// 变量不能生命前使用，会造成短暂性死区n++; // Errorlet n = 0;// 块级作用域for(let i = 0; i &lt; 10; ++i) &#123; setTimeout(() =&gt; &#123; console.log(i); &#125;, 100 * i);&#125;// 变量只在自己块作用下有效&#123; let n = 0;&#125;n ++; // Error// const 声明的变量不能更改变量值const LEN = 20;LEN = 1; // Error 不能改变常量值（只读属性也是类似） 解构数组解构、对象解构 对数组解构，需要索引相同； 对对象解构，需要 property 相同； 1234567891011121314151617181920212223242526272829303132333435363738394041// 交换变量值let a: number = 1, b: number = 2;[b, a] = [a, b];let [a, ...b] = [1,2,3,4]; // 使用 ...展开数组let [,a,,b] = [1,2,3,4]; // 选择性取数组数据let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a, b &#125; = o; // 这里不需要clet &#123;c, ...d&#125; = o; // 使用 ...展开对象 d是个对象// 当对象解构时，重命名属性名let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a: c, b: d &#125; = o; // 注意：此时a,b不能被访问到；冒号不再标注变量的类型// 解构时，使用默认值function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject;&#125;// 在声明时使用解构，并提供默认值function f(&#123; a, b = 0 &#125; = &#123; a: "haha" &#125;): void &#123; console.log(a, b);&#125;f(&#123; a: "yes" &#125;); f(); f(&#123;&#125;); // Error 既然选择传参，定要传递属性a]]></content>
      <categories>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typescript基础数据类型]]></title>
    <url>%2F2018%2F06%2F30%2Ftypescript%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[typescript 类型注解在 typescript 使用 : 类型 来标注变量具体的数据类型，对 javascript 变量随意性有了具体类型约束。 布尔值 boolean1let bool: boolean = true; 数字 numbertypescript 和 javascript 一样，所有数字都是以浮点数形式存储的，支持二、八、十、十六进制数字的变量。1234let number1: number = 0b1010, number2: number = 100, number3: number = 0o172, number4: number = 0x17fb; 字符串 string12345let str1: string = 'hello', str2: String = 'hello', str3: string = "hello", str4: string = `hello`, str5: string = `$&#123;str4&#125;` 任意值 any使用 any 类型的变量目的：躲避掉编译时类型检查 1234// 当你只知道一部分数据类型时，可以使用 any 声明数组let arr: any[] = [1, true, 'hello', function() &#123; alert(1); &#125;];arr[100] = true; 数组 Arraytypescript 使用两种方法定义数组。 在元素类型后面紧跟着 [] 使用数组泛型 Array&lt;元素类型&gt; 123let numArr: number[] = [1,2,3,4,5,6], strArr: Array&lt;string&gt; = ['hello', 'world'], arr: any[] = [1, true, 'hello', function() &#123; alert(1); &#125;]; 元组 Tuple如果一个数组的项的类型和个数都确定的话，可以使用元组来声明变量。 12let myTuple1: [string, number] = ['hello', 123];let myTuple2: [string, number] = [ 123', hello']; // Error 数据类型和数据要匹配 当访问已知索引的数据时，可使用其 api 来操作数据；访问一个越界的元素的，此时会使用联合类型 (string | number):123456let tuple: [string, number] = ['hello', 123];let ch = tuple[0].slice(-1);let ch1 = tuple[1].slice(-1); // Error 数组没有该方法tuple[3] = 'world'; // 'world' 的数据类型为string，在联合类型(string|number)中tuple[4] = true; // Error boolean不在联合类型中 枚举 enum枚举是对 javascript 数据类型的补充。意义为：物以类聚。为一组数据赋予一好听的名字。枚举成员不能有数值 1234567891011// 普通枚举使用enum Color &#123;Green, Red, Pink&#125;let myColor: Color = Color.Green; // 0 已知项=&gt;索引let myColor1: string = Color[2]; // 'Pink' 已知索引=&gt;具体项// 手动改变枚举项的索引, 后面项索引一次叠加enum Color1 &#123;Green, Red = 3, Pink, Orange = 10&#125;let myColor: Color1 = Color1.Pink; // 4 空值 void 只能给数据类型为 void 的变量赋值为 undefined | null； 函数返回值类型为 void，实际返回值和 javascript 一样为 undefined； 1234function fn(msg: string): void&#123; console.log(msg); // 'void 测试！'&#125;console.log( fn('void 测试！') ); // undefined undefined 和 null默认情况下，这两种类型是其他类型的子类型。比如：可以使用 undefined|null 赋值给类型为 number 的变量。 NeverNever 表示永不存在值的类型。never 类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。(个人认为这个类型很鸡肋) 类型断言可认为类型转换, 不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。类型断言两种方式： &lt;数据类型&gt; as 推荐使用，当你在TypeScript里使用JSX时，只有as语法断言是被允许的。 123let str: any = 'hello world!';console.log( (&lt;string&gt;str).length, (str as string).length ); // 12 12 注意这种类型转换是能是大范围转换为小范围，例如：any =&gt; 其他类型，不能 number =&gt; string123let strNum: string = '156';console.log( (strNum as number).toFixed(2) ); // Error 不能转换！]]></content>
      <categories>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typescript 简介]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%88%9D%E5%A7%8Btypescript%2F</url>
    <content type="text"><![CDATA[typescript 的概念typescript 是 javascript 的扩展，是 javascript 的超集，并且是一门由微软开发的跨平台、跨浏览器的开源语言，主要用于开发大型应用级软件。 typescript 和 javascript正如上述，typescript 是 javascript 的超级，是 javascript 的扩展，typescript 具有 es5-7 全部语法规范。 typescript 和 javascript有一下联系： 引入类、接口、模块的概念，虽然 javascript 之前也有，不过 typescript 中更加规范。 将 .ts 文件编译成 .js文件时，存在类型检查，不再像 js 一样拥有变量类型及个数的随意性。 始终于 javascript。在 .ts 文件中可直接写 js 代码，最后编译成也是 js 代码（毕竟浏览器的脚本语言默认就是 javascript）。 安装 typescriptnpm 安装 npm i -g typescript npm update -g typescript 更新 typescript 到最新版 tsc -v 查看 typescript 版本（更过 tsc 命令, tsc --help）。 demo: 使用 typescript 编写 helloworld12345function printHelloWorld(msg) &#123; return `$&#123;msg&#125; write hello world!`;&#125;console.log( printHelloWorld('typescript') ); 源文件： 使用 tsc + 文件路径 -w(--watch) 自动编译 .ts 文件，默认是编译成与 .ts 文件同目录的 .js 文件。由此可见，.ts 文件可自动被编译成 ECMAscript5 语法规则的 .js文件。 结果： 更多 typescript学习链接： typescript 中文文档 typescript 具体语法详解 typescript 源码 网友博客]]></content>
      <categories>
        <category>typescript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[闭包]]></title>
    <url>%2F2018%2F06%2F29%2F%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包的概念函数之间存在嵌套关系，并且内部函数可随时访问外部函数的局部变量（或者形参）。它是依托函数来创建的，因为只有函数有自己的作用域结构。 作用能避免污染全局环境下保存函数内部的局部变量。仅允许外界通过特定的函数接口来访问（或设置）局部变量。利用这一特性，可发现不少前端库为了实现模块化、不污染全局均使用了闭包，比如比较熟悉的 jquery。 危害由于闭包暴露出的外部接口可被随时调用，因此该函数常驻内存中，该函数接口又会依赖外部函数，因此整个外部函数及其内部私有数据常驻内存中，这样的话内存开销就比较大了，会导致网页性能的问题。在 ie 中可能会造成内存泄漏。 解决方式是：在函数退出之前全部删除变量或者给其赋值为 null，便于垃圾回收。 使用闭包 demo123456789// 闭包保存变量值for(var i = 0; i &lt; 10; ++i) &#123; ((i) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(i) &#125;, 10 * i); &#125;)(i);&#125; 12345678910111213141516171819202122232425262728// 闭包模拟数据库let dataOperation = (() =&gt; &#123; var jsonArr = [&#123; id: 1, username: 'Bob', pwd: '123456' &#125;, &#123; id: 2, username: 'Alice', pwd: '654321' &#125;, &#123; id: 3, username: 'Jack', pwd: '666666' &#125;]; return &#123; getData(id) &#123; return jsonArr.filter(json =&gt; json.id === id); &#125;, setData(myJson) &#123; let index = jsonArr.findIndex(json =&gt; json.username === myJson.username); jsonArr.splice(index, 1, myJson); console.log(jsonArr); &#125; &#125;&#125;)();]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue 特殊特性]]></title>
    <url>%2F2018%2F06%2F09%2FVue-%E7%89%B9%E6%AE%8A%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[keyvue 给相同父元素的子元素绑定 key 值的目的：唯一标识元素。当不同元素有相同的标识时，会发生渲染错误。常用之处： 和 v-for 一起使用进行列表渲染 在 transition-group 组件中标识不同子元素。 1234567891011121314151617181920212223242526272829303132333435/*CSS.fade-enter-active, .fade-leave-active &#123; opacity: 1; transition: opacity 2s;&#125;.fade-enter, .fade-leave-to &#123; opacity: 0;&#125;HTML&lt;div id="wrap"&gt; &lt;button @click="flag = !flag"&gt;点击&lt;/button&gt; &lt;transition-group name="fade" tag="div"&gt; &lt;p v-show="flag" :key="p1"&gt;这是p1元素&lt;/p&gt; &lt;p v-show="flag" :key="p2"&gt;这是p2元素&lt;/p&gt; &lt;a v-show="flag" :key="a"&gt;这是a元素&lt;/a&gt; &lt;/transition-group&gt; &lt;div v-for="item in arr" :key="item.id"&gt;&#123;&#123;item.id&#125;&#125; -- &#123;&#123;item.name&#125;&#125;&lt;/div&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true, arr: [ &#123;id: 1, name: 'Bob'&#125;, &#123;id: 2, name: 'Hello'&#125; ] &#125;&#125;); ref用来给元素/组件添加引用信息。所有信息会记录在父组件 $refs 对象上。通过这个信息可以获取到对应的 DOM 节点或者子组件实例，比如操作 dom 节点或获取子组件信息啊。1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;h3 ref="title"&gt;Vue 特殊属性--ref的使用&lt;/h3&gt; &lt;ref-demo ref="demo"&gt;&lt;/ref-demo&gt; &lt;button @click="demoTest"&gt;点击&lt;/button&gt;&lt;/div&gt;*/Vue.component('ref-demo', &#123; template: `&lt;div&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;`, data() &#123; return &#123; msg: '我是ref对组件的测试demo!' &#125; &#125;&#125;);const vm = new Vue(&#123; el: 'div', methods: &#123; demoTest() &#123; console.log( this.$refs ); &#125; &#125;&#125;); 注意: $refs 是根实例被挂载之后（mounted）才有的，并且它不是响应式的，不能在模板中做数据绑定。1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;div ref="box"&gt;这是普通DOM元素!&lt;/div&gt; &lt;button @click="$refs.box.innerText += 'lalala'"&gt;点击&lt;/button&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, beforeCreate() &#123; console.log('box' in this.$refs); // false &#125;, created() &#123; console.log('box' in this.$refs); // false &#125;, beforeMount() &#123; console.log('box' in this.$refs); // false &#125;, mounted() &#123; console.log('box' in this.$refs); // true &#125;&#125;); slot插槽作用场景：父组件优雅地 html 代码传递到子组件中来，实现自定义元素组件的内容分发。父组件决定向子组件传递什么内容，而子组件决定怎么讲内容分发。 不使用 slot 弊端 值得注意的是：如果不使用 slot 进行内容分发且组件元素有内容的话，则自定义组件元素内容将会丢失，因为整个组件会被其 template 替换 1234567891011121314151617181920212223242526/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt;啊啊啊！我显示不出来啊&lt;/my-component&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125; &#125; &#125;&#125;); 匿名插槽/默认插槽匿名插槽没有 name 属性，在模板中在需要的位置直接使用 slot ，会把整个自定义组件元素的全部内容放在此位置。 1234567891011121314151617181920212223242526272829303132/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;div&gt; hhh, 我会在模板中显示的！ --- 并且能够传值&#123;&#123;parentMsg&#125;&#125;&lt;/div&gt; &lt;/my-component&gt;&lt;/div&gt;*/var myComponent = &#123; template: `&lt;div&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt; &lt;!-- 将显示在这 --&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125;&#125;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', parentMsg: 'a msg from parent!' &#125;, components: &#123; 'my-component': myComponent &#125;&#125;); 匿名插槽的特点： 把整个 html 插入子组件制定位置。 可设置默认值。 具名插槽使用 name 给多个插槽起名，使组件元素内容分开至 template 不同位置，并且具名插槽可以在模板中复用。 12345678910111213141516171819202122232425262728293031323334353637/*&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;header slot="head"&gt; &lt;span&gt;这是根元素头部信息---&#123;&#123;headMsg&#125;&#125;&lt;/span&gt; &lt;/header&gt; &lt;footer slot="foot"&gt; &lt;div&gt;这是根元素尾部信息---&#123;&#123;footMsg&#125;&#125;&lt;/div&gt; &lt;/footer&gt; &lt;/my-component&gt;&lt;/div&gt;*/var myComponent = &#123; template: `&lt;div&gt; &lt;slot name="head"&gt;&lt;/slot&gt; &lt;h3&gt;&#123;&#123;msg&#125;&#125;&lt;/h3&gt; &lt;slot name="foot"&gt;&lt;/slot&gt; &lt;/div&gt;`, data() &#123; return &#123; msg: '这是子组件!' &#125; &#125;&#125;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', headMsg: '我通过slot传给子组件的头部信息!', footMsg: '我通过slot传给子组件的尾部信息!', &#125;, components: &#123; 'my-component': myComponent &#125;&#125;); 具名插槽的特点： 通过给插槽命名实现父组件向子组件传递的内容分发。 命名插槽可多次使用。 命名插槽也可设置默认值。 作用域的插槽/带数据的插槽在子组件内 slot 中绑定数据，在父作用域下的插槽内容通过 slot-scope 接收，并由父组件在子组件中以怎样的方式渲染出数据。 123456789101112131415161718192021222324252627282930313233/*HTML&lt;div id="wrap"&gt; &lt;my-component&gt; &lt;template slot-scope="data"&gt; &lt;h3&gt;&#123;&#123;data.mydata&#125;&#125;&lt;/h3&gt; &lt;!-- &lt;li&gt;&#123;&#123;data.mydata&#125;&#125;&lt;/li&gt; --&gt; &lt;/template&gt; &lt;/my-component&gt;&lt;/div&gt;*/Vue.component('my-component', &#123; template: `&lt;div&gt; &lt;h3&gt;这是子组件&lt;/h3&gt; &lt;slot v-for="(index, item) of list" :mydata="index" &gt; &lt;/slot&gt; &lt;/div&gt;`, data() &#123; return &#123; list: [1,2,3,4] &#125; &#125;&#125;);const vm = new Vue(&#123; el: '#wrap'&#125;); isis 用处一is 和 component 搭配使用实现组态组件的来回切换。并且还可能在组件外部嵌套缓存 keep-alive 或者 动画 transition。 123456789101112131415161718192021222324252627282930313233343536373839/*HTML&lt;div id="wrap"&gt; &lt;transition name="fade" mode="out-in"&gt; &lt;keep-alive&gt; &lt;component :is="currentComponent"&gt;&lt;/component&gt; &lt;/keep-alive&gt; &lt;/transition&gt; &lt;button @click="change"&gt;组件切换&lt;/button&gt;&lt;/div&gt;*/var component1 = &#123; template: '&lt;div&gt;组件1&lt;/div&gt;'&#125;;var component2 = &#123; template: '&lt;div&gt;组件2&lt;/div&gt;'&#125;;var component3 = &#123; template: '&lt;div&gt;组件3&lt;/div&gt;'&#125;;var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', currentComponent: 'component1' &#125;, methods: &#123; change() &#123; this.currentComponent = 'component' + (this.currentComponent.slice(-1) % 3 + 1); &#125; &#125;, components: &#123;component1, component2, component3&#125;&#125;); is 用处二当循环渲染某些组件时，出现 html 模板渲染错误， 需要 is 来避免 dom 渲染的 bug。12345678910111213141516171819202122232425/*HTML&lt;div id="wrap"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr-item v-for="n in 6" :num="n" :key="n"&gt;&lt;/tr-item&gt; &lt;!-- 循环6行tr --&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;Vue.component('tr-item', &#123; template: `&lt;tr&gt; &lt;td&gt;&#123;&#123;num&#125;&#125;&lt;/td&gt; &lt;/tr&gt;`, props: &#123; num: Number &#125;&#125;);const vm = new Vue(&#123; el: 'div'&#125;);*/ 糟糕的结果： 正确处理如下：123456789101112131415161718192021222324/*HTML&lt;div id="wrap"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr is="tr-item" v-for="n in 6" :num="n" :key="n"&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;/div&gt;Vue.component('tr-item', &#123; template: `&lt;tr&gt; &lt;td&gt;&#123;&#123;num&#125;&#125;&lt;/td&gt; &lt;/tr&gt;`, props: &#123; num: Number &#125;&#125;);const vm = new Vue(&#123; el: 'div'&#125;);*/]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue 全局API]]></title>
    <url>%2F2018%2F06%2F07%2FVue-%E5%85%A8%E5%B1%80API%2F</url>
    <content type="text"><![CDATA[全局 API不在构造器内部、挂载在构造函数 Vue 下的 API，也就是 Vue 的静态方法。 Vue.directive自定义指令。实现对普通 DOM 元素底层操作。语法：Vue.directive({String}id, {funciton|object}defination)、`directives分类： 全局自定义指令 可用于所有 Vue 实例 局部自定义指令 仅仅作用于当前组件 自定义指令的钩子函数: bind 只调用一次，指令第一次绑定到元素上调用。用来初始化设置。 inserted 被绑定的元素插入到父节点时调用（要保证父节点存在）。 update 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。 componentUpdated 指令所在组件的 VNode 及其子 VNode 全部更新后调用。 unbind 只调用一次，指令与元素解绑时调用。 每个自定义指令钩子函数的内部参数（直接拷贝官网上的）: el 绑定的 DOM 元素，可读。 binding 包含众多属性的对象: name 指令名，不包含 v- 前缀。 value 指令绑定值，通常是 string、json格式。 oldValue 指令绑定的前一个值，仅在 update、componentUpdated钩子中使用。无论值是否改变都可用。 expression 字符串形式的指令表达式。例如：v-mydirective=&quot;1 + 1&quot;, expression 就是 1 + 1。 arg 传给指令的参数，可选。例如：v-mydirective:foo, arg就是foo。 modifiers 一个包含修饰符的对象。例如：v-my-directive.foo.bar，修饰符对象是：{foo: true, bar: true} VNode Vue编译生成的虚拟节点。移步 VNode API 来了解更多详情。 oldNode 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中使用。 1234567891011121314151617181920212223242526272829303132/*HTML &lt;div id="wrap"&gt; &lt;input type="text" v-demo:foo.bar.lala="1 + 1" v-model="msg"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;textarea v-focus&gt;&lt;/textarea&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;, directives: &#123; demo: &#123; inserted(el, binding, VNode) &#123; console.log(el); // &lt;input type="text"&gt; console.log(binding.name); // focus console.log(binding.value); // 2 console.log(binding.expression); // 1 + 1 console.log(binding.arg); // foo console.log(binding.modifiers); // &#123;bar: true, lala: true&#125; &#125; &#125;, focus: &#123; inserted(el) &#123; el.focus(); &#125; &#125; &#125;&#125;); Vue.extendvue 扩展构造器。主要来服务 Vue.component 来创建全局组件。语法：Vue.extend({object}options)需要注意的是： 组件和主组件有一点很大不同：data 选项必须是函数类型，且要返回 json 类型。（防止因为组件复用时，一数据变化其他也会变化）。 该全局 API 的模板选项会覆盖挂载点。 123456789101112131415/*HTML &lt;div id="wrap"&gt;&lt;/div&gt;*/var myExtend = Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; msg: 'Vue.extend demo!' &#125; &#125;&#125;);new myExtend().$mount('div'); Vue.filter过滤器。用来简单过滤后台请求的数据。语法：Vue.filter({string}id, {function}defination)、filters注意： 过滤器的 function 选项第一个参数是被过滤的数据。 多过虑器（前一个过滤器返回值作为后一个过滤器的第一个参数），用 | 隔开。 12345678910111213141516171819202122/*HTML &lt;div id="wrap"&gt;&#123;&#123;msg | msgReverse(flag)&#125;&#125;&lt;/div&gt; 全局过滤器 Vue.filter('msgReverse', function(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125;);*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;, filters: &#123; // 局部过滤器 msgReverse(str, bool) &#123; return bool ? str.split('').reverse().join('') : str; &#125; &#125;&#125;); Vue.component全局注册组件，相对于局部组件不需要引入。语法： Vue.component({string}id, {object|function}defination)。 12345678910111213141516171819202122232425262728293031323334/* HTML&lt;div id="wrap"&gt; &lt;my-component1&gt;&lt;/my-component1&gt; &lt;my-component2&gt;&lt;/my-component2&gt;&lt;/div&gt;*/Vue.component('my-component1', Vue.extend(&#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;));// 实现同样的功能，第二个参数直接使用 &#123;&#125; 形式，比 Vue.extend 更高效、简洁!Vue.component('my-component2', &#123; template: '&lt;div&gt;&#123;&#123;componentMsg&#125;&#125;&lt;/div&gt;', data() &#123; return &#123; componentMsg: '组件内部数据!' &#125; &#125;&#125;);var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;&#125;); Vue.use引入组件（插件）。语法：Vue.use({object|function}plugin) 123456// 先使用require引入通过npm安装的包，在Vue对象上引入插件。 var VueRouter = require('vue-router'), Vue = require('vue'), VueAwesomeSwiper = require('vue-awesome-swiper');Vue.use(VueRouter).use(VueAwesomeSwiper)....]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Vue 内部指令]]></title>
    <url>%2F2018%2F06%2F06%2FVue-%E5%86%85%E9%83%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[v-text更新元素的 innerText，但不会渲染带有标签的字符串。 1234567891011/*HTML &lt;div v-text="msg"&gt;&lt;/div&gt; // 如同模板字符串 &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; */var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;&#125;); 使用 v-text 内部指令和使用模板字符串看似效果一样，但是当网速慢导致 data 未编译成功时，v-text 就不会将 msg 渲染出；但是模板字符串却很尴尬的暴露出来了，这时需要使用 v-cloak 了。 v-html更新元素的 innerHTML ，如果在前端操作该 innerHTML（复杂 HTML），通常把它作为组件剥离出去。当然也可以直接动态渲染可信的 HTML 。渲染未知来源（用户提供的内容）的 HTML 这是非常危险的，因为容易受到 xss 攻击。 1234567891011/*HTML &lt;div v-html="msg"&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: '&lt;p&gt;hello world!&lt;/p&gt;' &#125;&#125;); v-show条件渲染。根据表达式来改变data 内部数据值的真假，从而来改变元素 css 中 display属性。 12345678910111213141516/*HTML&lt;div id="wrap"&gt; &lt;div v-show="flag"&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt; &lt;button @click="flag = !flag"&gt;toggle show&lt;/button&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!', flag: true &#125;&#125;); v-if v-else v-else-if条件渲染。根据表达式来改变data 内部数据值的真假，从文档中清除/显示指定元素，和 v-show 不同的是，它并不通过改变元素 css 中 display属性来控制元素的显示隐藏，而是直接动态添加/删除元素。v-else 必须在 v-if/v-else-if 后面; v-else-if 前面必须有 v-if/v-else 1234567891011121314151617/*HTML&lt;div id="wrap"&gt; &lt;div v-if="isMan"&gt;I am a man!&lt;/div&gt; &lt;div v-else-if="isAlice"&gt;I am Alice!&lt;/div&gt; &lt;div v-else&gt;I am a woman!&lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; isMan: false, isAlice: false &#125;&#125;); v-for列表渲染。遍历并渲染 array、object、number、string。更多的是遍历 json 数组。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*HTML&lt;div id="wrap"&gt; &lt;div class="demo-string"&gt; &lt;ul&gt; &lt;li v-for="(ch, index) in str" :key="index"&gt;&#123;&#123;ch&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-number"&gt; &lt;ul&gt; &lt;li v-for="(n, index) in arr" :key="index"&gt;&#123;&#123;n&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json-arr"&gt; // important! &lt;ul&gt; &lt;li v-for="item in jsonArr" :key="item.id"&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="demo-json"&gt; &lt;p v-for="item in myJson"&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; */var vm = new Vue(&#123; el: '#wrap', data: &#123; str: 'abcdefg', arr: [1,2,3,4,5], jsonArr: [&#123; id: 1, name: 'Bob' &#125;, &#123; id: 2, name: 'Alice' &#125;, &#123; id: 3, name: 'Jack' &#125;], myJson: &#123; name: 'Facker', age: 20, sex: '男' &#125; &#125;&#125;); 可注意到：使用 v-for 渲染列表时，Vue 建议给每一项绑定一个唯一 key 属性，它用来保证数据的唯一性，如果有相同的 key 值，将会导致渲染错误。 v-on事件监听。简写成 @, 分为两类： 用在普通 HTML 元素上来监听 DOM 事件。实现相关的逻辑处理功能。 用在自定义元素组件上来监听子组件触发的自定义事件，从而实现子组件通过事件流的方式向父组件传递消息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*HTML&lt;div&gt; &lt;button @click="fn1"&gt;按钮1&lt;/button&gt; &lt;button @click="fn2('haha', $event)"&gt;按钮2&lt;/button&gt; &lt;my-component @my-event='fn3'&gt;&lt;/my-component&gt; &lt;!-- 子组件触发my-event自定义事件时，父组件执行fn3函数。注意此时形参中的$event不再是事件对象event，而是子组件向父组件传递的信息。 但是在实参处写$event也没意义，因为可以在形参接受到全部消息 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button @click="toParentMsg"&gt;子组件按钮!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; toParentMsg() &#123; this.$emit('my-event', this.msg, 'gogo'); // 按钮点击时，触发自定义事件my-event &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn1(event) &#123; // 监听DOM事件，如果无实参则methods中对应函数的第一个形参是事件对象event console.log(event); &#125;, fn2(str, event) &#123; // 监听DOM事件，如果有实参则使用$event向形参传递事件对象event console.log( str, event ); &#125;, fn3(str1, str2) &#123; // 监听子组件my-event事件 console.log( str1, str2 ); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); 事件修饰符: 对事件的附加修饰。 .prevent 阻止默认事件 .stop 阻止事件冒泡 .native 监听根组件的原生事件。用来自定义元素组件触发原生事件时，调用根组件内部函数。 还有其他事件修饰符… Vue 官网 123456789101112131415161718192021222324252627282930313233343536373839// .native demo/*HTML&lt;div&gt; &lt;my-component @click.native="fn"&gt;&lt;/my-component&gt; &lt;!-- 注意：事件是绑定在自定义元素组件上的，而不是子组件模板中的普通元素上，否则会调用子组件内部的fn方法 --&gt;&lt;/div&gt;*/var componentChild = &#123; template: `&lt;button&gt;点击试试!&lt;/button&gt;`, data() &#123; return &#123; msg: '我是子组件,给父组件传递信息了!' &#125; &#125;, methods: &#123; fn() &#123; console.log('hahaha'); &#125; &#125;&#125;;var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!' &#125;, methods: &#123; fn() &#123; console.log('lalala'); &#125; &#125;, components: &#123; myComponent: componentChild &#125;&#125;); v-bind绑定 DOM 属性，分为： 绑定合法属性，属性值是 data 内部的值。 绑定自定义属性，通过 props 实现父组件向子组件传递消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 以绑定 class、style 两个合法属性为例/*css.classA &#123; width: 100px; height: 100px; &#125;.classB &#123; background: skyblue; border-radius: 2px;&#125;*//*HTML&lt;div id="wrap"&gt; &lt;!-- 绑定 style --&gt; &lt;div :style="&#123; width: width + 'px', height: height + 'px', borderRadius: borderRadius + 'px', background: bgColor &#125;"&gt; &lt;/div&gt; &lt;div :style="styleObj"&gt;&lt;/div&gt; &lt;div :style="[styleObj1, styleObj2]"&gt;&lt;/div&gt; &lt;!-- 绑定 class --&gt; &lt;div :class="&#123; classA: 'classA', classB: 'classB' &#125;"&gt; &lt;/div&gt; &lt;div :class="[classA, classB]"&gt;&lt;/div&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: 'div', data: &#123; msg: 'hello world!', width: 100, height: 100, borderRadius: 2, bgColor: 'pink', styleObj: &#123; width: '100px', height: '100px', background: 'pink' &#125;, styleObj1:&#123; width: '100px', height: '100px' &#125;, styleObj2:&#123; background: 'skyblue', borderRadius: '2px' &#125;, classA: 'classA', classB: 'classB' &#125;&#125;);// 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。/*HTML&lt;div id="wrap"&gt; &lt;my-component :to-child="msg"&gt;&lt;/my-component&gt; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello world!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;div&gt; &lt;h4&gt;这是子组件!&lt;/h4&gt; &lt;p&gt;父组件向子组件传递的消息是--&#123;&#123;toChild&#125;&#125;&lt;/p&gt; // 传递过来的消息在子组件模板中得到应用 &lt;/div&gt;`, props: ['toChild'] &#125; &#125;&#125;); 总结： 绑定多个内敛样式不如动态添加 class更方便。 绑定自定义属性，子组件通过props（可以是数组/对象）接受父组件的绑定值，实现父组件向子组件传递消息。极其重要！ v-model双向绑定。在表单控件 input、textarea、select或组件 components 上创建双向绑定。v-model 修饰符： .lazy 用表单的 change 事件代替 input 事件。 .trim 过滤掉首位空格。 .number 将字符串格式的 value 转换成数字。 v-model 仅是语法糖，负责监听用户的输入事件 input 来更新数据。底层一点: v-model 是靠 v-bind 对 value 值的绑定和监听表单 input 事件。 123456789101112131415161718192021222324/*HTML&lt;div id="wrap"&gt; &lt;!-- &lt;input type="text" v-model="msgInput"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; 等同下面--&gt; &lt;input type="text" :value="msgInput" @input="msgInput = $event.target.value"&gt;&lt;p&gt;&#123;&#123;msgInput&#125;&#125;&lt;/p&gt; &lt;!-- 组件上的双向绑定就是父子组件的通信过程 props、$emit --&gt; &lt;my-component v-model="msgComponent"&gt;&lt;/my-component&gt;&lt;p&gt;&#123;&#123;msgComponent&#125;&#125;&lt;/p&gt;&lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msgInput: 'hello world!', msgComponent: 'my msg from component!' &#125;, components: &#123; 'my-component': &#123; template: `&lt;input type="text" :value="value" @input="$emit('input', $event.target.value)"/&gt;`, props: ['value'] &#125; &#125;&#125;); v-pre跳过编译，显示原来的插值样式。123456789101112/*HTML&lt;div id="wrap" v-pre&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt; // 不显示 hello 而是 &#123;&#123;msg&#125;&#125;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-cloak避免实例未准备好而出现插值样式的尴尬页面。需要和 css 样式一同使用。1234567891011121314151617181920/*css[v-cloak] &#123; display: none;&#125;*//*HTML&lt;div id="wrap" v-cloak&gt; &#123;&#123;msg&#125;&#125; &lt;/div&gt;*/var vm = new Vue(&#123; el: '#wrap', data: &#123; msg: 'hello' &#125;&#125;); v-once单次渲染元素/组件后，元素/组件及其子节点全部作为静态内容不会被刷新渲染。对低开销的静态组件使用 v-once 指令可以优化性能。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[语义化标签、css3新增选择器、css3新增样式]]></title>
    <url>%2F2018%2F06%2F04%2F%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[什么是语义化很容易让编程人员、浏览器读懂代码的内容。 语义化的优点 页面结构更清晰，容易将网页分块，更便于开发维护 有利于搜索引擎的抓取能力、SEO 优化。 html5 新增常用的标签兼容性：ie9+ header : 网站头部，或者一个局域块的头部。 article : 定义一片文本区域，盛放文章等内容，常用在帖子、博客文章、评论、新闻。 nav： 盛放导航的盒子，链接排列。nav &gt; ul &gt;li &gt; a section : 局域块。article 专门盛放文本的，它可以盛放其他东西。 aside : 侧边栏，窗口左右边的能点击的锚点小块。 footer : 网站尾部，或者一个局域块的尾部。 figure : 展示图片及其描述。figcaption 定义 figure 的标题，它不能单独使用。 mark : 标记小部分内容。默认背景色是黄色，可用js改变。 canvas、svg、video、audio 等高级 h5 标签。 css3新增选择器属性选择器 E[attr] : 选择具有属性attr的E元素 E[attr = &#39;val&#39;] : 选择具有属性 attr、attr 值为 val 的E元素。 E[attr ~= &#39;val&#39;] : 选择具有属性 attr 、属性值中有一个（可能有几个属性值，它们以空格隔开）是 val 的E元素。 E[attr ^= &#39;val&#39;] : 选择具有属性attr、属性值以 val 开头的字符串的E元素，如果有多个属性值，只检测第一个值。 E[attr $= &#39;val&#39;] : 选择具有属性 attr、属性值以 val 结尾的字符串的E元素，如果有多个属性值，只检测最后一个值。 E[attr |= &#39;val&#39;] : 选择具有属性 attr、属性值是 val 或者 val 用 - 链接的的E元素。eg: div.[class |= ‘h’] E[attr *= &#39;val&#39;] : 选择具有属性 attr 、属性值包含 val 的字符串的E元素。 伪类选择器： E:first-child : 匹配父元素中第一个子元素、且元素种类为E。 E: last-child : 匹配父元素中最后一个子元素、且元素种类为E。 E:first-of-type : 匹配父元素中类型为E的第一个元素。 E:last-of-type : 匹配父元素类型中为E的最后一个元素。 E:nth-child(n) : 匹配父元素中第n个元素、元素类型为E。 E:nth-last-child(n) : 倒着数，匹配父元素中第n个、类型为E的元素。 E:nth-of-type(n) : 匹配父元素中第n个、类型为E的子元素。 E:nth-last-of-type(n): 倒着数，匹配父元素中第n个元素。 E:empty : 匹配没有内容的E元素。这里没有内容，指的是 innerHTML 为空、可以有 before、after E:target : 被锚点激活的E元素，某个元素的ID值是a链接的 href ，并且在前面加上#。例如：&lt;div id=&#39;box&#39;&gt;&lt;/div&gt; &lt;a href=&#39;#box&#39;&gt;&lt;/a&gt; 两个栓在一起。当鼠标点击a时候，div就会触发:target伪类样式。 E:checked: 已被选择的单、多选按钮。 E:enabled : 匹配可用状态的表单元素E。 E:disabled : 匹配不能使用的表单元素E。 E:not(选择器) : 匹配不包含指定选择器的元素 E:focus : 匹配获得焦点的元素E。 伪元素选择器： E::after : 选择E的伪元素 after E::before : 选择E的伪元素 before content 不能省，默认是内联元素，通常需要定位。 E::placeholder : 修饰表单元素E里面的 placeholder 属性值的样式。通常放在 input 里面，起到提示作用，当点击 input 时候，placeholder 仍然出现。通常 placeholder 是通过js模拟。 E::selection : 鼠标选择的样式（背景、color、text-shadow）。 E::first-letter : 第一个文字。 E::first-line : 第一行 伪类、伪元素注意点 对空元素添加 ::before ::after伪元素后，:empty 伪类还是有作用的。 两个伪元素::before ::after 通常和动画、转换、过度结合。实现图片层叠效果、达到节约元素的目的。 nth-child、nth-of-type 里面可以写： 数字、英文、类似 ab + b 表达式。 伪元素和伪类的区别伪类是直接给元素添加样式。伪元素是先添加元素再去定义样式。 css3 新增属性新增边框属性 border-radius : 设置边框圆角。分为水平方向和竖直方向上的圆角设置，用/隔开。 IE9+ box-shadow : 添加盒子阴影。多个阴影用 , 隔开。 IE9+ border-image : 用图片绘画边框（很少用）。 新增背景属性 background-clip 、 background-origin 、background-break。用的少。 background-size : cover | contain | auto | 具体长度、宽度。设置背景大小，通常也是考虑到背景图的大小来设置盒子大小（不是雪碧图）。 cover : 保证背景会覆盖盒子，但是可能背景不完全显示。 contain : 能等比缩放到盒子的边或者宽，但是不一定会完全覆盖盒子。 背景的复合写法：background: [其他颜色] background-image [background-repeat background-position / background-size]; 多背景用逗号隔开。 新增的文本效果 white-space : normal | nowrap | pre | pre-wrap 规定 空格、换行、缩进的处理方式。使超出文本出现省略号：white-space: nowrap; overflow: hidden; text-overflow:ellipsis; word-wrap : normal | break-word 对单词是否拆分。 text-shadow : 文本阴影。规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-full-color : 设置文字填充色。个人觉得和 color 并无区别。 text-stroke-color : 设置文本描边色。 text-stroke-width : 设置文字边界宽度。 更多的css3新增属性具体参见：css手册]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[this 指向]]></title>
    <url>%2F2018%2F05%2F26%2Fthis-%E6%8C%87%E5%90%91%2F</url>
    <content type="text"><![CDATA[this 的出现javascript 函数可在不同环境下执行，因此需要使用 this 来标识函数所在的执行环境。也就是说，设计 this 的目的就是在函数内部指代函数当前的运行环境的。 this 指向情形如下： 全局下的 this 指向 对象字面量内部 构造函数内部 call、apply、bind 手动改变 this 指向 es6箭头函数内部 全局下的 this 指向在浏览器中，全局下的 this 指向 window 对象；在 node 环境中，则指向 global 对象。 1234var fn = function() &#123; console.log( this ); &#125;; // windowfn(); // 等同this.fn()、window.fn()console.log( this ); //window 对象字面量内部的 this 指向很容易认为 this 就是指向该对象字面量，其实这种情况只是其中之一。正确的判断出 this 指向需要看哪个对象直接调用了函数。 12345678910111213141516var age = 0; var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;var fn = obj2.getAge = obj1.getAge;fn(); // window.fn() 0obj2.getAge(); // 2 构造函数内部的 this 指向通过 new 命令的执行机制，知道构造函数内部的 this 就是指向创建出的实例。 12345678910111213141516171819function Person(name, age, sex) &#123; var a = 0; function sss() &#123; // 闭包 a ++; console.log(a); &#125; this.say = sss; this.name = name; this.age = age; this.sex = sex;&#125;var oPersopn = new Person('Bob', 20, '男');oPersopn.say(); // 1oPersopn.say(); // 2var oPersopn1 = new Person('Alice', 18, '女');oPersopn1.say(); // 1 call、apply、bind 手动改变 this 指向函数内部 this 就是使用 call、apply 、bind 调用函数时第一个参数。以 call 为例： 123456789101112var obj1 = &#123; age: 1, getAge: function() &#123; console.log(this.age); &#125;&#125;;var obj2 = &#123; age: 2&#125;;obj1.getAge.call(obj2); // 2 es6箭头函数内部 this 指向记住它和父级作用域的 this 一致。 123456789101112131415161718var age = 0;var obj = &#123; age: 1, getAge1: function() &#123; setTimeout(function() &#123; console.log( this.age ); &#125;); &#125;, getAge2: function() &#123; setTimeout(() =&gt; &#123; console.log( this.age ); &#125;); &#125;&#125;obj.getAge1(); // 0obj.getAge2(); // 1 一道经典面试题1234567891011121314var a = 10;var foo = &#123; a: 20, bar: function()&#123; var a = 30; console.log( this.a ); &#125;&#125;foo.bar(); // 20 没毛病(foo.bar)(); // 20 匿名函数自执行，但该函数仅限于foo对象中的变量使用。等同于foo.bar()(foo.bar, foo.bar)(); // 10 逗号运算符，返回最右边的表达式。匿名函数自执行,this指向window(foo.bar = foo.bar)(); // 10 foo.bar被重新赋值一个函数，然后再执行这个匿名函数，但是此时的函数被赋值之后，this指向了全局变量window]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[本地存储]]></title>
    <url>%2F2018%2F05%2F18%2F%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[前端存储方式 cookie localStorage sessionStorage indexDB (待续) cookie cookie 运行在服务器端，存放在客户端（用户浏览器）。 cookie 是绑定在域名上的。不同域名存放的 cookie 位置和内容不同。cookie 能够在同个域名多页面使用，但正常情况下，不能跨域使用。 不同浏览器的 cookie 存储位置不同，更不能相互使用。 cookie 存放内容空间很小，不同浏览器存放大小不同，一般4KB左右，20个左右。 cookie 默认无效时间是会话结束。当用户关闭浏览器时就会失效。 cookie 安全性不高，别人能够拿到本地 cookie 然后进行 cookie 欺骗。 cookie 作用：实现身份验证、保存用户登陆信息、信息跟踪等。 cookie 的工作原理当页面每次发送 http 请求时，浏览器都会携带与目标 URL（domain+path） 相关的 cookie 信息。有则自动会添加到 request cookie 中（即使不需要某一 cookie。 所以，cookie 大小不宜太大），伴随着 http 请求发送到服务器。 cookie 的属性name value domain path expires/max-age httponly secure 等。 name value: cookie 的键值对儿。 domain: 控制 cookie 对那个域有效。默认值是创建 cookie 时所在网页的域名。即 URL 中的 host。 手动设置 cookie 的域的话，可以设置 domain 为本域、父域，不能是公共后缀。如：本域为 www.google.com.hk 。可以将 domain 设置为 www.google.com.hk、google.com.hk，但是不能设置为 .com.hk com.hk .hk 等。 path: 控制 cookie 作用目录。默认是创建 cookie 的文件目录。这样 domain+path（即URL） 就决定了cookie 能够被哪些页面共享了。 expries/max-age: 规定 cookie 的过期时间。默认 cookie 的生存期是会话结束时, cookie 失效。expires 是一个时间点,单位毫秒； max-age 是一个以秒为时间的时间段。max-age 可能的值：负数(有效期为会话结束)、0(删除cookie)、正数(有效期为创建时刻 + 最大时间)。例如，设置过期时间是两年后过期：expires = new Date(new Date().getTime() + 2 365 24 3600 1000).toGMTString() 或者 max-age = 2 365 24 * 3600; httponly: 用来指定 cookie 能否通过js访问到。默认情况下，是可以通过js获取、更改、删除 cookie 的。cookie 设置 httpOnly 选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。客户端不能通过js设置 httponly 值的，必须是服务端设置。好处是将 cookie 设置为 httponly 可以减轻 xss 攻击的危害，防止 cookie 被窃取，提高 cookie 的安全性。 secure: 用来设置 cookie 在 https 等安全协议下，cookie 才会被发送到服务端。默认情况下，不管是http、https 协议的请求都会把 cookie 发送到服务端。注意：只有是在 https 安全协议下的 web 站点，才能设置 secure 的 cookie; 只保证 cookie 与服务器之间的数据传输加密，而保存在本地的 cookie 文件并不加密。唯一一个非名值对儿，只包含 secure 一个单词例如：document.cookie = ‘_name=bai; secure’; cookie 的编码防止 cookie 的 key、 value 中含有空格、分号、等号特殊符号。所以 cookie 在设置时需要编码，获取时需要解码。编码、解码：escape/unescape encodeURIComponent/decodeURIComponent encodeURI/decodeURI可参考：cookie 编码介绍 js实现对cookie的增加、删除、修改1234567891011121314151617181920212223242526272829303132333435var dealCookie = &#123; // name, value, time(以年为单位), domain, path, secure, httponly(只能在服务端设置) set : function (json)&#123; var name = json.name, value = json.value, time = json.time, domain = json.domain, path = json.path, secure = json.secure, cookieStr = encodeURIComponent(name) + '=' + encodeURIComponent(value); if(time) cookieStr += '; expires=' + new Date(new Date().getTime() + time * 365 * 24 * 3600 * 1000).toGMTString(); if(domain) cookieStr += '; domain=' + domain; if(path) cookieStr += '; path=' + path; if(secure &amp;&amp; location.protocol.slice(0, -1) === 'https') cookieStr += '; secure'; document.cookie = cookieStr; &#125;, // 找到匹配项返回 get : function (name)&#123; var regArr = document.cookie.match( new RegExp('(\\s|^)' + encodeURIComponent(name) + '=([^;]*)(;|$)') ); return regArr ? decodeURIComponent(regArr[2]) : null; &#125;, // 当cookie的name/domain/path相同时，才可删除 unset : function (name, domain, path) &#123; var obj = &#123;&#125;; obj.name = name; obj.domain = domain; obj.path = path; obj.time = -1; dealCookie.set(obj); &#125;&#125;; 其他链接: 详解cookie localStorage 本地持久化存储，存储容量可达到5M以上，除非手动删除，否则一直存在。、 localStorage 存储的信息在同域内共享。受到同源策源影响，不能跨域。 localStorage 的数据也是以键值对儿形式存储，但不像cookie一样往返于客户端和服务端之间，避免浪费带宽。 localStoarge 一些属性、方法 localStorage.length; 获取localStorage的长度 localStorage.setItem(k, v); （可以适当使用JSON.stringify/JSON.parse） localStorage.getItem(k); localStorage.removeItem(k); 局部删除 localStorage.clear(); 全部删除 localStoarge 缺点 localStorage 是对字符串操作，如果存储数据很多，会消耗内存空间，使页面变卡。 localStorage 内的数据在隐私模式下不可读取。 localStorage 不会被爬虫爬取到，不要用它完全代替URL传参。 localStorage 的storage事件1window.addEventListener('storage', function(e)&#123;...&#125;, false); 需要注意的是： 在本页进行localStorage操作（新增、修改、删除）时，本业不会触发storage事件，但是别的页面会触发。在IE里面，本页面也会触发storage事件。 storage事件对象e有很多属性，重要的有。key、newValue、oldValue、url。 sessionStoarge 受同源策源的影响，数据只能在本标签页存储，不同窗口（标签页）的 sessionStoarge 数据不可共享。 有和localStoarge 相同的API，都是Storage类的实例。 sessionStoarge和localStorage的区别：持久化存储、窗口级别的存储。 indexDB]]></content>
      <categories>
        <category>h5</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象 OOP]]></title>
    <url>%2F2018%2F05%2F17%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-OOP%2F</url>
    <content type="text"><![CDATA[对象对象是实物的抽象，也可以说它是一个容器，其中封装了属性和方法。 面向对象的特点面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程，更适合多人合作的大型软件项目。 构造函数工厂化的方式生成对象，如果实例对象属性、方法各不同，可放在构造函数内部。 如果有相同的属性、方法，那就直接把它们挂载在原型对象上。 构造函数内部机制（new 命令干了什么？） 创建了空的中间对象 将中间对象的原型 __proto__ 指向构造函数的 prototype 属性，this 指向中间对象。 执行构造函数内部代码，给中间对象挂载属性、方法。 隐式返回 this 。 123456789101112131415function Person(name, age) &#123; this.name = name; this.age = age;&#125;Person.prototype.showName = function() &#123; console.log(this.name); &#125;;Person.prototype.desc = '我是Person的原型!';console.log(new Person('Bob', 20));// new 操作符后干了什么???function personTemp(Fn, ...args) &#123; var obj = Object.create(Fn.prototype); // 创建了空对象，并把它的原型设置为构造函数的原型对象。 Fn.apply(obj, args); // 执行构造函数内部代码，改变this指向使其指向空对象，并给它挂载属性和方法。 return obj; // 返回挂载后的对象。&#125;console.log(personTemp('Bob', 20)); 构造函数返回值构造函数返回值默认是已经封装好了的 this 对象。如果返回基本类型，则返回值无效，相当于 new 命令会忽略这支语句，但是一旦返回 object 类型的数据，将会替代 this 。 12345678910111213function Demo1(name) &#123; this.name = name; return 'test'&#125;function Demo2(age) &#123; this.age = age; return [1,2,3]&#125;new Demo1('Bob') // &#123;name: Bob&#125;new Demo2(20) // [1,2,3] 原型每个函数都有 prototype 属性,该属性值是一个对象，即原型对象。原型对象出现的原因是挂载实例的公共属性和方法，减少创建每个实例的内存消耗。原型内部有一属性是指向构造函数的 constructor 。通过构造函数访问到原型对象：构造函数.prototype 实例对象访问原型对象实例对象.__proto__ 或者 Object.getPrototypeOf(实例对象)（推荐）综上,有一个恒等式; 实例对象.__proto__ === 构造函数.prototype 函数对象的原型函数不仅含有 prototype 属性，同时它也是对象，是 Function 实例化的结果。有如下结论： 123456var Test = function() &#123; alert(1); &#125;;Test.__proto__ === Function.prototype // trueTest.prototype.__proto__ === Object.prototype; // trueFunction.prototype === Fucntion.__proto__ // trueFunction.__proto__.prototype // undefinedFunction.__proto__.__proto__ // Object.prototype 原型链每个实例化对象都有原型，而原型又是对象，也能找到原型，一直寻找原型至 Object.prototype （它的原型为null）结束。 123var oTest = new Test();oTest.__proto__.__proto__ === Object.prototype // trueObject.prototype.__proto__ // null in、for-inin 判断对象是否含有某个属性，for-in 遍历属性如果在该对象并未找，它会顺着原型链查找，一直找到源头 Object.prototype 下的属性、方法，没有则返回 undefined，通常继承会利用这种特性；for-in 遍历对象及其祖先的可枚举、非 Symbol 属性时，如果只遍历自身的属性、方法，可以使用 Object.hasOwnProperty(obj) 来实现过滤。 另外，可用 isPrototypeOf 来判断该对象是否式参数的原型对象。 继承子类拥有父类的属性和方法，但是不对其进行更改，且每个子类实例互不影响。 构造函数继承构造函数继承又称类继承，意思是在子类的构造函数内部调用父类的构造函数（期间修改this指向）。 123456789101112131415function Parent(name) &#123; this.name = name;&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); // 构造方法继承的关键处 this.age = age; this.sex = sex;&#125;var child = new Child('Bob', 20, '男');child.showName(); // 报错 可以实现对父类属性、方法的继承。但是却继承不到父类原型上的属性、方法。 原型继承通过prototype实现原型继承，将子类原型对象指向父类的一个实例。 1234567891011121314151617181920function Parent(name) &#123; this.name = name; this.num = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child(20, '男');var child1 = new Child(21, '女');child.num.push(4);child1.num // [1,2,3,4]child.name // undefined 缺点：如果父类上存在引用类型的数据，一旦一个子类对其改变，其他子类的数据同样改变; 子类无法改变父类内部属性值，即使父类需要参数也不能传参，一旦传参，所有实例含有相同属性值。 组合继承继承父类、原型上的属性及其方法 123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = new Parent(); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 缺点是：调用了两次父类的构造函数。第一次为了继承父类的属性、方法。第二次是为了继承父类原型上的属性、方法，那何必不直接将子类原型指向父类的原型呢？ 在子类遍历属性时，岂不更快吗？ 不用创建父类实例，岂不更节约空间？ 组合继承的优化123456789101112131415161718function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Parent.prototype; Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child ); 似乎已经完美地继承了父类且所有子类实例可以共享父类原型的属性方法。但是，没办法知道子类的父类是谁啊？另外，子类和父类共用一个prototype，一旦子类修改了prototype，父类的prototype也会修改(比如constructor)。 最终的组合优化1234567891011121314151617181920212223242526272829function Parent(name) &#123; this.name = name; this.arr = [1,2,3];&#125;Parent.prototype.showName = function() &#123; console.log(this.name);&#125;;function Child(age, sex) &#123; Parent.call(this, name); this.age = age; this.sex = sex;&#125;Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;var child = new Child('Bob', 20, '男');console.log( child );/* 如果不支持Object.create(): if(!Object.create) &#123; Object.create = function(obj) &#123; function Fn() &#123;&#125;; Fn.prototype = obj; return new Fn(); &#125;; &#125;*/ Object.create(Parent.prototype)：以父类的原型为原型来创建一个空对象，子类原型指向这个空对象。这样就可以很清楚地看到子类地父类。 获取父类名：实力对象.__proto__.__proto__.constructor.name es6实现继承123456789101112131415161718192021222324class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; console.log( this.name ); &#125;&#125;class Child extends Parent &#123; constructor(name, age, sex) &#123; super(name); this.age = age; this.sex = sex; &#125; getAge() &#123; console.log( this.age ); &#125;&#125;var child = new Child('Bob', 20, '男');console.log( child );]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[原生js获取DOM节点]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%8E%9F%E7%94%9Fjs%E8%8E%B7%E5%8F%96DOM%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[获取DOM元素通过元素ID获取受到ID唯一性的限制，只能获取一个元素； 兼容所有浏览器 1document.getElementById('el-id') 通过元素的类名获取获取 obj 对象下的含有该类名的所有元素，返回一个类数组 HTMLCollection； 不兼容ie8- 1obj.getElementsByClassName('el-className') 通过标签获取obj 对象下是该标签的节点，返回一个类数组 HTMLCollection； 兼容所有浏览器。 1obj.getElementsByTagName('el-name') H5新增获取元素的Api，不兼容ie7-可获取单个节点、多个节点, 返回的是 NodeList 类数组 12obj.querySelector('选择器') obj.querySelectorAll('选择器') children 获取获取对象obj下第index（index是非负整数）个子元素 1obj.children[index] 动态获取和静态获取动态获取获取的可以是 HTMLCollection、动态节点。DOM元素进行添加、修改删除子元素，该动态列表也会相应的更新，可看做 HTMLCollector 是 DOM 节点的引用。 对应的动态方法： obj.getElementsByTagName(‘el-name’) obj.getElementsByClassName(‘el-className’) obj.children[index] 静态获取获取的可以是 NodeList、静态节点。DOM 元素进行添加、修改删除子元素，该动态列表不会更新，可看做 HTMLCollector 是 DOM 节点的复制。通常来说，静态方法会比动态方法慢。 对应的动态方法： obj.querySelector(‘选择器’) obj.querySelectorAll(‘选择器’) jq获取的节点列表、对象，jq的获取类似于querySelector 举个栗子来表明以上两种获取方式1234567891011121314151617181920212223242526272829303132&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;!function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.getElementsByTagName('li'); console.log( aLi.length ); // 6 oUl.removeChild(aLi[aLi.length - 1]); /*父元素把最后一个li对象删除，aLi发生变化*/ console.log( aLi.length ); // 5&#125;();+function() &#123; var oUl = document.getElementsByTagName('ul')[0], aLi = document.querySelectorAll('li'); console.log( aLi.length ); // 5 var oLi = document.createElement('li'); oUl.appendChild(oLi); /*父元素在最后添加一个li对象,aLi无变化*/ console.log( aLi.length ); // 5&#125;(); &lt;/script&gt; 遍历类数组先把类数组 HTMLCollection、NodeList、arguments 转换成数组，再使用数组方法遍历： 123456789101112131415161718192021&lt;div id="wrap"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; var aLi = document.querySelectorAll('li'); [].slice.call(aLi).forEach((oLi, index) =&gt; &#123;console.log( oLi, index );&#125;); [...aLi].forEach((oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); Array.from(aLi, (oLi, index) =&gt; &#123;console.log( oLi, index )&#125;); &lt;/script&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
  </entry>
</search>
